# --------------------------------------
# THE IMPLEMENTATION OF THE STANDARD
# FUNCTIONS
# --------------------------------------

CONST SP        $00;   # STACK POINTER
CONST FP_ADDR   $02;   # ADDRESS OF FRAME POINTER
CONST INBUF    $200;   # MONITOR INPUT BUFFER

CONST MON_GETLN $FD6A; # MONITOR INPUT ROUTINE
CONST MON_COUT  $FDED; # MONITOR CHAR OUT ROUTINE

# TODO
FN   ADD(A_PTR:2,B_PTR:2,
       C_PTR:2,SIZE:1);
FN   SUB(A_PTR:2,B_PTR:2,
       C_PTR:2,SIZE:1);
FN   MUL(A_PTR:2,B_PTR:2,
       C_PTR:2,SIZE:1);
FN   DIV(A_PTR:2,B_PTR:2,Q_PTR:2,
       R_PTR:2,SIZE:1);
FN:1 CMP(A_PTR:2,B_PTR:2,SIZE:1);
FN:1 CMP_S(A_PTR:2,B_PTR:2,SIZE:1);
FN   NUM_TO_STR(NUM_PTR:2,NUM_SIZE:1,
       RADIX:1,STR_PTR:2);
FN   NUM_TO_STR_S(NUM_PTR:2,NUM_SIZE:1,
       RADIX:1,STR_PTR:2);
FN:1 STR_TO_NUM(STR_PTR:2,RADIX:1,
       NUM_PTR:2,NUM_SIZE:1);
FN:2 ALLOCATE(SIZE:1);
FN   CLEAR(PTR:2,SIZE:1);

#
# GET A NULL-TERMINATED LINE OF TEXT
# INTO INBUF
# RETURN - NUMBER OF CHARS READ
#
FN:1 GET_LINE() {
  MON_GETLN();
  SET INBUF[^X,1] = 0;
  RETURN ^X;
}

#
# PRINT A CHARACTER TO THE SCREEN
#
FN PRINT_CHAR(CHAR:1) {
  SET ^A = CHAR;
  MON_COUT();
}

#
# PRINT A NUMBER TO THE SCREEN
# N     - POINTER TO NUMBER
# SIZE  - SIZE OF NUMBER IN BYTES
# RADIX - RADIX TO PRINT 
#
FN PRINT_NUM(N_PTR:2,RADIX:1,SIZE:1) {
  VAR ZERO:2 = ALLOCATE(SIZE);
  CLEAR(ZERO,SIZE);
  PRINT_NUM_1(N_PTR,SIZE,RADIX,ZERO);
}
 
FN PRINT_NUM_1(N_PTR:2,SIZE:1,
   RADIX:1,ZERO:2) { 
  VAR QUOT:2 = ALLOCATE(SIZE);
  VAR REM:2  = ALLOCATE(SIZE);
  VAR DIGIT:1;
  DIV(N_PTR,@RADIX,QUOT,REM,SIZE);
  IF (CMP(QUOT,ZERO,SIZE) > 0) {
     PRINT_NUM_1(QUOT,SIZE,RADIX,ZERO);
  }
  SET DIGIT = REM[0,1];
  IF (DIGIT < 10) {
    PRINT_CHAR(DIGIT + '0');
  }
  ELSE {
    PRINT_CHAR(DIGIT - 10 + 'A');
  }
}

