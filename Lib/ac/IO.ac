# --------------------------------------
# THE APPLECORE COMPILER, V1.0
# IO FUNCTIONS
# --------------------------------------
# MONITOR INPUT BUFFER
CONST INBUF       $200;
# MONITOR LINE INPUT
CONST MON_GETLN1  $FD6F; 
# MONITOR CHAR OUT
CONST MON_COUT   $FDED;
# MONITOR PRINT BYTE AS HEX
CONST MON_PRBYTE $FDDA;
#
# GET NULL-TERMINATED LINE INTO INBUF
# RETURN - NUMBER OF CHARS READ
#
FN:1 GET_LINE() {
  MON_GETLN1();
  SET INBUF[^X,1]=0;
  RETURN ^X;
}
#
# PRINT A CHARACTER VIA MON_COUT
#
FN PRINT_CHAR(CHAR:1) {
  SET ^A = (CHAR OR $80);
  MON_COUT();
}
#
# PRINT A STRING
#
FN PRINT_STRING(STR_PTR:2) {
   WHILE (STR_PTR[0,1] > 0) {
     PRINT_CHAR(STR_PTR[0,1]);
     INCR STR_PTR;
   }
}
#
# PRINT A NUMBER AS HEX DIGITS
#
FN PRINT_HEX(N_PTR:2,SIZE:1) {
   VAR I:1=SIZE;
   WHILE (I > 0) {
     SET ^A=N_PTR[I-1,1];
     MON_PRBYTE();
     DECR I;
   }
} 
#
# CONVERT NUMBER TO STRING
# N     - POINTER TO NUMBER
# SIZE  - SIZE OF NUMBER
# RADIX - RADIX
# STR   - POINTER TO STRING
#  
FN NUM_TO_STR(N:2,SIZE:1,RADIX:1,STR:2) 
{
  VAR ZERO:2 = ALLOCATE(SIZE);
  SET IDX=0;
  N_TO_S_REC(N,SIZE,RADIX,STR,ZERO);
  SET STR[IDX,1]=0;
}

VAR IDX:1;

FN N_TO_S_REC(N:2,SIZE:1,RADIX:1,
   STR:2,ZERO:2) 
{
  VAR QUOT:2 = ALLOCATE(SIZE);
  VAR REM:2  = ALLOCATE(SIZE);
  VAR DIGIT:1;
  DIV(N,@RADIX,QUOT,REM,SIZE);
  IF (CMP(QUOT,ZERO,SIZE) > 0) 
  {
     N_TO_S_REC(QUOT,SIZE,@RADIX,
       STR,ZERO);
  }
  SET STR[IDX,1]=DIGIT_TO_CHAR(REM[0,1]);
  INCR IDX;
}

FN:1 DIGIT_TO_CHAR(DIGIT:1) 
{
  IF (DIGIT < 10) 
  {
     RETURN DIGIT+'0';
  }
  RETURN DIGIT-10+'A';
}

