<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>

<HEAD>

<TITLE>The AppleCore Language Specification, v1.0</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<STYLE type="text/css">
.toc{list-style:none;}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
.part{margin:auto;text-align:center}
</STYLE>
</HEAD>

<BODY >
<!--HEVEA command line is: hevea -fix -O AppleCore-Spec-v1.0.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF section 1 -->

<BR>
<TABLE CLASS="title">
<TR><TD>
<H1 CLASS="titlemain"><B>The AppleCore Language Specification, v1.0</B></H1>
<H3 CLASS="titlerest">Robert L. Bocchino Jr.<BR>
Pittsburgh, PA</H3></TD>
</TR></TABLE><BR>
<!--TOC section Contents-->

<H2 CLASS="section">Contents</H2><!--SEC END -->

<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">1&nbsp;&nbsp;Introduction and Rationale</A>
<LI CLASS="li-toc"><A HREF="#htoc2">2&nbsp;&nbsp;Lexical Structure</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">2.1&nbsp;&nbsp;White Space</A>
<LI CLASS="li-toc"><A HREF="#htoc4">2.2&nbsp;&nbsp;Identifiers</A>
<LI CLASS="li-toc"><A HREF="#htoc5">2.3&nbsp;&nbsp;Keywords</A>
<LI CLASS="li-toc"><A HREF="#htoc6">2.4&nbsp;&nbsp;Constants</A>
<LI CLASS="li-toc"><A HREF="#htoc7">2.5&nbsp;&nbsp;Symbols</A>
<LI CLASS="li-toc"><A HREF="#htoc8">2.6&nbsp;&nbsp;Comments</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc9">3&nbsp;&nbsp;Syntax</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc10">3.1&nbsp;&nbsp;Source Files</A>
<LI CLASS="li-toc"><A HREF="#htoc11">3.2&nbsp;&nbsp;Declarations</A>
<LI CLASS="li-toc"><A HREF="#htoc12">3.3&nbsp;&nbsp;Statements</A>
<LI CLASS="li-toc"><A HREF="#htoc13">3.4&nbsp;&nbsp;Expressions</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc14">4&nbsp;&nbsp;Semantic Checking</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc15">4.1&nbsp;&nbsp;Representation of Values</A>
<LI CLASS="li-toc"><A HREF="#htoc16">4.2&nbsp;&nbsp;Attribution</A>
<LI CLASS="li-toc"><A HREF="#htoc17">4.3&nbsp;&nbsp;Constant-Value Expressions</A>
<LI CLASS="li-toc"><A HREF="#htoc18">4.4&nbsp;&nbsp;Expressions Appearing at Global Scope</A>
<LI CLASS="li-toc"><A HREF="#htoc19">4.5&nbsp;&nbsp;Size and Signedness</A>
<LI CLASS="li-toc"><A HREF="#htoc20">4.6&nbsp;&nbsp;Number of Function Arguments</A>
<LI CLASS="li-toc"><A HREF="#htoc21">4.7&nbsp;&nbsp;Semantic LValues</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc22">5&nbsp;&nbsp;Code Generation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc23">5.1&nbsp;&nbsp;Source Files</A>
<LI CLASS="li-toc"><A HREF="#htoc24">5.2&nbsp;&nbsp;Global Declarations</A>
<LI CLASS="li-toc"><A HREF="#htoc25">5.3&nbsp;&nbsp;Program Stack</A>
<LI CLASS="li-toc"><A HREF="#htoc26">5.4&nbsp;&nbsp;Function Bodies</A>
<LI CLASS="li-toc"><A HREF="#htoc27">5.5&nbsp;&nbsp;Statements</A>
<LI CLASS="li-toc"><A HREF="#htoc28">5.6&nbsp;&nbsp;Expressions</A>
<LI CLASS="li-toc"><A HREF="#htoc29">5.7&nbsp;&nbsp;Address Computation for Semantic LValues</A>
<LI CLASS="li-toc"><A HREF="#htoc30">5.8&nbsp;&nbsp;Size Adjustment</A>
</UL>
</UL>
<!--NAME contents.html-->
<BR>
<BR>
<!--TOC section Introduction and Rationale-->

<H2 CLASS="section"><A NAME="htoc1">1</A>&nbsp;&nbsp;Introduction and Rationale</H2><!--SEC END -->

AppleCore is a C-like programming language for the Apple II series of
computers. A cross-compiler from Java (e.g., running on a Mac or PC)
to the Apple II is under development.<BR>
<BR>
The idea of AppleCore is to provide a &#8220;core language for programming
the Apple II.&#8221; The motivation is as follows:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Programming the Apple II is both nostalgic and just plain fun.
<LI CLASS="li-enumerate">The Apple II is a small machine. Therefore it needs a
 lightweight programming model (i.e., without complicated runtime
 overhead in space or time). The programming model must also provide
 (1) tight control over the layout of generated code and (2) easy
 integration with assembly-language support routines such as those
 provided by the System Monitor or Applesoft.
<LI CLASS="li-enumerate">The native programming models on the Apple II are inadequate.
 Assembly language is powerful but painfully low-level. Applesoft,
 on the other hand, is a disaster. It lacks even the most basic
 abstraction required of a sane programming environment, including
 scoped loops, scoped functions with local variables, and variable
 names longer than <EM>two letters</EM>! Applesoft does have nice
 support for numeric and string input and output, so if you just want
 to write short programs that read and write things, it's handy. But
 for any but the tiniest programs, Applesoft code becomes an
 unreadable mess. In terms of control abstraction Applesoft is much
 worse than assembly language, because it forces you to branch to
 numbered lines, whereas in assembly language you can <TT>JMP</TT> and
 <TT>JSR</TT> to symbolic labels with meaningful names.
</OL>
The goal of AppleCore is to rectify this situation by providing a
&#8220;low-level high-level&#8221; language (at about the same level of
abstraction as C, but without structs) that's both useful and fun to
program with. First, it's a compiled language, so it should run
faster than Applesoft. Second, it's modular and supports separate
compilation. The entire core language needs only a few kilobytes of
support routines; additional routines can be linked in as needed.
Third, AppleCore strikes a balance between power and efficiency.
Notably, it supports integer arithmetic on fixed-size variables of up
to 255 bytes. This power does come at a cost in terms of speed for
single-byte arithmetic that could be done in registers; however, if
that speed is needed, one can easily call into assembly language
arithmetic routines. Fourth, it provides easy integration with
assembly language routines: you can say things like &#8220;load `A' into
the accumulator and call $FDED&#8221; that are impossible to say directly
in Applesoft.<BR>
<BR>
The main things that AppleCore lacks, and that Applesoft provides, are
automatic memory management and floating-point computation. I've left
out memory management to keep things very simple. Basically, as a
programmer I can't live happily without control abstractions (loops
and functions); but once I have them I'm perfectly content to
synthesize data abstractions on my own. If this becomes too much of a
pain, a library for memory management can be added without difficulty,
after the fashion of C. (Applesoft actually provides garbage
collection, but it works very poorly, causing the machine to seize up
when the memory limit is reached.) I've left out floating-point
computation mainly because I'm most interested in text processing and
integer computations; but again, FP computations can be added without
too much difficulty. In the mean time, one can fake FP computations
by encoding FP literals as string data and calling into the Applesoft
FP routines to convert from strings to FP numbers and back, and to
compute using the FP numbers. Applesoft is actually quite good at
this.<BR>
<BR>
<!--TOC section Lexical Structure-->

<H2 CLASS="section"><A NAME="htoc2">2</A>&nbsp;&nbsp;Lexical Structure</H2><!--SEC END -->

Before parsing a source file, the source text is separated into
<EM>tokens</EM>. There are four classes of tokens: identifiers,
keywords, constants, and symbols.<BR>
<BR>
<!--TOC subsection White Space-->

<H3 CLASS="subsection"><A NAME="htoc3">2.1</A>&nbsp;&nbsp;White Space</H3><!--SEC END -->

<A NAME="sec:lexical:white-space"></A>
White space consists of any sequence of the following characters:
space (ASCII SP, value $20), newline (ASCII NL, value $0A), carriage
return (ASCII CR, value $0D), and horizontal tab (ASCII HT, value
$09). Whitespace is syntactically relevant only in the following
ways:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I>Separation of tokens.</I> When a whitespace character or end of
file appears immediately after a non-whitespace character, that
signifies the end of a token.
<LI CLASS="li-enumerate"><I>End of line.</I> An end-of-line sequence (<TT>EOL</TT>) is a
 comment terminator (see Section&nbsp;<A HREF="#sec:lexical:comments">2.6</A>). As
 usual, the definition of <TT>EOL</TT> is platform-dependent: on the
 Apple II it is CR, on UNIX it is NL, and on Windows it is CR
 followed by NL.
</OL>
The lexer may also count source lines (using <TT>EOL</TT>) to provide
line numbers for error messages.<BR>
<BR>
<!--TOC subsection Identifiers-->

<H3 CLASS="subsection"><A NAME="htoc4">2.2</A>&nbsp;&nbsp;Identifiers</H3><!--SEC END -->
<A NAME="Identifiers"></A>
An identifier is a sequence of letters, underscore character, and
digits that is not a keyword. The first character must be a letter.
Upper- and lowercase letters are distinct. A single identifier may
contain at most 32 characters.<BR>
<BR>
<!--TOC subsection Keywords-->

<H3 CLASS="subsection"><A NAME="htoc5">2.3</A>&nbsp;&nbsp;Keywords</H3><!--SEC END -->

The following sequences of characters are reserved for use as keywords
and may not be used as identifiers:<BR>
<BR>
<TT>
</TT><DIV CLASS="center"><TT>
</TT><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><TT>AND</TT></TD>
<TD ALIGN=left NOWRAP><TT>CONST</TT></TD>
<TD ALIGN=left NOWRAP><TT>DATA</TT></TD>
<TD ALIGN=left NOWRAP><TT>DECR</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>ELSE</TT></TD>
<TD ALIGN=left NOWRAP><TT>FN</TT></TD>
<TD ALIGN=left NOWRAP><TT>IF</TT></TD>
<TD ALIGN=left NOWRAP><TT>INCLUDE</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>INCR</TT></TD>
<TD ALIGN=left NOWRAP><TT>NOT</TT></TD>
<TD ALIGN=left NOWRAP><TT>OR</TT></TD>
<TD ALIGN=left NOWRAP><TT>RETURN</TT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><TT>SET</TT></TD>
<TD ALIGN=left NOWRAP><TT>VAR</TT></TD>
<TD ALIGN=left NOWRAP><TT>XOR</TT></TD>
<TD ALIGN=left NOWRAP><TT>WHILE</TT></TD>
</TR></TABLE><TT>
</TT></DIV><TT>
</TT><BR>
<BR>
Following Apple II tradition (mostly because the original Apple II had
no support for lower-case letters), AppleCore keywords are uppercase.
That means that the same words in lowercase (or a combination of
upper- and lowercase) are not recognized as keywords, so those
sequences of characters are available for use as identifiers.<BR>
<BR>
<!--TOC subsection Constants-->

<H3 CLASS="subsection"><A NAME="htoc6">2.4</A>&nbsp;&nbsp;Constants</H3><!--SEC END -->

<A NAME="sec:lexical:constants"></A>
There are three types of constants: integer constants, string
constants, and character constants. <BR>
<BR>
<B>Integer constants.</B> Integer constants may be written in
decimal or hexadecimal form. A decimal integer constant consists of
one or more decimal digits <TT>0</TT> through <TT>9</TT>. For example,
<TT>1</TT> and <TT>123</TT> are valid integer constants in decimal form. A
hexadecimal integer constant consists of a dollar sign <TT>$</TT>
followed by by one or more hexadecimal digits <TT>0</TT> through <TT>9</TT>
or <TT>A</TT> through <TT>F</TT>. For example, <TT>$1</TT>, <TT>$A</TT>, and
<TT>$00FF</TT> are valid integer constants in hexadecimal form.<BR>
<BR>
Integer constants represent values with up to 255 bytes of precision
(i.e., in the range 0 through 2<SUP>255 &sdot; 8</SUP>&minus;1, inclusive). It
is a compile-time error to write an integer constant with a value
larger than that.<BR>
<BR>
<B>String constants.</B> A string constant is a sequence of
characters enclosed in double quotes (<TT>"..."</TT>). A string constant
represents a sequence of ASCII characters, one for each character
appearing in the double-quotes, except that the character sequence
<TT>\$</TT> has the special meaning described below.<BR>
<BR>
Since not all ASCII characters have printable representations, an
<EM>escape sequence</EM> may be used to represent an arbitrary ASCII
value (printable or non-printable). An escape sequence consists of a
backslash <TT>\</TT> followed by a dollar sign <TT>$</TT> and two
hexadecimal digits. The whole sequence represents the single
character with the ASCII value given by the digits. For example, the
string constant<BR>
<BR>
<DIV CLASS="center"><TT>"Hello, world!\$0D"</TT></DIV><BR>
<BR>
represents a string consisting of the characters <TT>Hello, world!</TT>
followed by a CR character. Similarly, the quote character <TT>"</TT>
can be embedded in a string constant with the sequence <TT>\$22</TT>.<BR>
<BR>
<B>Character constants.</B> A character constant consists of a
single-quote character <TT>'</TT>, followed by a printable ASCII
character, followed by another single-quote character. It represents
the ASCII value associated with the character. For example, the
constant <TT>'A'</TT> represents the value $41.<BR>
<BR>
<!--TOC subsection Symbols-->

<H3 CLASS="subsection"><A NAME="htoc7">2.5</A>&nbsp;&nbsp;Symbols</H3><!--SEC END -->

AppleCore uses the symbols shown in Figure&nbsp;<A HREF="#fig:symbols">1</A>, each of
which is a separate token.
<BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=center NOWRAP><B>Symbol</B></TD>
<TD ALIGN=left NOWRAP><B>Meaning</B></TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>@</TT></TD>
<TD ALIGN=left NOWRAP>Denotes the address of a variable</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>^</TT></TD>
<TD ALIGN=left NOWRAP>Denotes a 6502 register expression</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>*</TT></TD>
<TD ALIGN=left NOWRAP>Multiplication</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>/</TT></TD>
<TD ALIGN=left NOWRAP>Division</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>+</TT></TD>
<TD ALIGN=left NOWRAP>Addition</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>-</TT></TD>
<TD ALIGN=left NOWRAP>Negation (as unary operator); subtraction (as binary
operator)</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>&lt;&lt;</TT></TD>
<TD ALIGN=left NOWRAP>Left shift</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>&gt;&gt;</TT></TD>
<TD ALIGN=left NOWRAP>Right shift</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>&gt;=</TT></TD>
<TD ALIGN=left NOWRAP>Greater than or equal to</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>&lt;=</TT></TD>
<TD ALIGN=left NOWRAP>Less than or equal to</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>&gt;</TT></TD>
<TD ALIGN=left NOWRAP>Greater than</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>&lt;</TT></TD>
<TD ALIGN=left NOWRAP>Less than</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>=</TT></TD>
<TD ALIGN=left NOWRAP>Equal to; assignment</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>(</TT> and <TT>)</TT></TD>
<TD ALIGN=left NOWRAP>Encloses function parameters and arguments, parenthesized expressions</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>{</TT> and <TT>}</TT></TD>
<TD ALIGN=left NOWRAP>Encloses statement blocks</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>[</TT> and <TT>]</TT></TD>
<TD ALIGN=left NOWRAP>Pointer dereference</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>;</TT></TD>
<TD ALIGN=left NOWRAP>Terminates declarations and statements</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>:</TT></TD>
<TD ALIGN=left NOWRAP>Separates variable declaration from size</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>,</TT></TD>
<TD ALIGN=left NOWRAP>Separates function parameters and arguments; separates index from size in dereference</TD>
</TR>
<TR><TD ALIGN=center NOWRAP><TT>\</TT></TD>
<TD ALIGN=left NOWRAP>Signifies unterminated string data</TD>
</TR></TABLE>
</DIV>
<BR>
<BR>
<DIV CLASS="center">Figure 1: Symbols used in AppleCore syntax.</DIV><BR>
<BR>

<A NAME="fig:symbols"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE>
<!--TOC subsection Comments-->

<H3 CLASS="subsection"><A NAME="htoc8">2.6</A>&nbsp;&nbsp;Comments</H3><!--SEC END -->

<A NAME="sec:lexical:comments"></A>
The character <TT>#</TT> indicates a comment; all text to the next end
of line (or end of file, if there is no end of line) are ignored by
the lexer. Multi-line comments are indicated by preceding each line
with <TT>#</TT>.<BR>
<BR>
<!--TOC section Syntax-->

<H2 CLASS="section"><A NAME="htoc9">3</A>&nbsp;&nbsp;Syntax</H2><!--SEC END -->

<A NAME="sec:syntax"></A>
The syntax description below uses the following conventions:
<UL CLASS="itemize"><LI CLASS="li-itemize">
The symbol <SUP>*</SUP> denotes zero or more instances of the entity
 preceding it.
<LI CLASS="li-itemize">Italicized parentheses <I>(  )</I> group the enclosed symbols and
 do not denote program text.
<LI CLASS="li-itemize">Italicized brackets <I>[  ]</I> signify that the enclosed symbols are
 optional (i.e., they may occur zero or one time). They do not
 denote program text.
<LI CLASS="li-itemize">The nonterminal <I>identifier</I> stands for any identifier
 as defined in Section <A HREF="#Identifiers">2.2</A>.
<LI CLASS="li-itemize">The nonterminals <I>integer-const</I>,
 <I>string-const</I>, and <I>char-const</I> stand for integer,
 string, and character constants as defined in
 Section&nbsp;<A HREF="#sec:lexical:constants">2.4</A>.
<LI CLASS="li-itemize">The nonterminal <I>size</I> refers to an integer constant
 whose value is between 1 and 255 (inclusive).
<LI CLASS="li-itemize">Text and symbols in <TT>typewriter</TT> font (including
 non-italicized parentheses and brackets) denote literal program
 text.
</UL>
<!--TOC subsection Source Files-->

<H3 CLASS="subsection"><A NAME="htoc10">3.1</A>&nbsp;&nbsp;Source Files</H3><!--SEC END -->

<A NAME="sec:syntax:source-files"></A>
The basic syntactic unit of an AppleCore program is a <EM>source
 file</EM>, i.e., an input file presented to the AppleCore compiler for
compilation. The compiler translates the source file into an assembly
file which is then linked with other assembly files as discussed in
Section&nbsp;<A HREF="#sec:code-gen:source-files">5.1</A> to form a complete executable
program.<BR>
<BR>
An AppleCore source file is given by zero or more
declarations (Section&nbsp;<A HREF="#sec:syntax:decls">3.2</A>):<BR>
<BR>
<DIV CLASS="center"><I>source-file</I> ::= <I>decl</I><SUP>*</SUP></DIV><BR>
<BR>
<!--TOC subsection Declarations-->

<H3 CLASS="subsection"><A NAME="htoc11">3.2</A>&nbsp;&nbsp;Declarations</H3><!--SEC END -->

<A NAME="sec:syntax:decls"></A>
A declaration is a constant declaration, a data declaration, a
variable declaration, a function declaration, or an include
declaration:<BR>
<BR>
<DIV CLASS="center"><I>decl</I> ::= <I>const-decl</I> |
 <I>data-decl</I> | <I>var-decl</I> | <I>fn-decl</I>
 | <I>include-decl</I></DIV><BR>
<BR>
<B>Constant declarations.</B> A constant declaration consists of the
keyword <TT>CONST</TT>, an identifier, an expression, and a terminating
semicolon:<BR>
<BR>
<DIV CLASS="center"><I>const-decl</I> ::= <TT>CONST</TT> <I>identifier
 expr</I> <TT>;</TT></DIV><BR>
<BR>
<B>Data declarations.</B> A data declaration consists of the keyword
<TT>DATA</TT>, an optional identifier representing a label for the data,
an expression or a string constant, and a terminating semicolon. A
backslash may optionally follow the string constant, indicating that
the string is unterminated (see
Section&nbsp;<A HREF="#sec:code-gen:global-decls">5.2</A>).<BR>
<BR>
<DIV CLASS="center"><I>data-decl</I> ::= <TT>DATA</TT> <I>[ identifier ]
 ( expr</I> | <I>( string-const [</I> \ <I>] ) )</I>
 <TT>;</TT></DIV><BR>
<BR>
<B>Variable declarations.</B> A variable declaration consists of the
keyword <TT>VAR</TT>, an identifier representing the variable name, a
signed or unsigned size, an optional initializer expression, and a
terminating semicolon:<BR>
<BR>
<DIV CLASS="center"><I>var-decl</I> ::= <TT>VAR</TT> <I>identifier</I> <TT>:</TT>
 <I>size [</I> <TT>S</TT> <I>] [</I> <TT>=</TT> <I>expr ]</I> <TT>;</TT></DIV><BR>
<BR>
<B>Function declarations.</B> A function declaration consists of the
keyword <TT>FN</TT>, an optional signed or unsigned size, an identifier
representing the function name, the function parameters enclosed in
parentheses, and the function body:<BR>
<BR>
<DIV CLASS="center"><I>fn-decl</I> ::= <TT>FN</TT> <I>[</I> <TT>:</TT> <I>size
 [</I> <TT>S</TT> <I>] ] identifier</I> <TT>(</TT> <I>fn-params</I>
 <TT>)</TT> <I>fn-body</I></DIV><BR>
<BR>
The function parameters are a comma-separated list of zero or more
parameters:<BR>
<BR>
<DIV CLASS="center"><I>fn-params</I> ::= <I>[ fn-param (</I> <TT>,</TT>
 <I>fn-param )</I><SUP>*</SUP> <I>]</I></DIV><BR>
<BR>
A parameter consists of an identifier representing the parameter name
and a size:<BR>
<BR>
<DIV CLASS="center"><I>fn-param</I> ::= <I>identifier</I> <TT>:</TT>
 <I>size [</I> <TT>S</TT> <I>]</I></DIV><BR>
<BR>
A function body is either zero or more variable declarations and
statements enclosed in braces, or a semicolon indicating an externally
defined function:<BR>
<BR>
<DIV CLASS="center"><I>fn-body</I> ::= <TT>{</TT> <I>var-decl</I><SUP>*</SUP>
 <I>stmt</I><SUP>*</SUP> <TT>}</TT> | <TT>;</TT></DIV><BR>
<BR>
<B>Include declarations.</B> An include declaration consists of the
keyword <TT>INCLUDE</TT>, a string constant, and a terminating semicolon:<BR>
<BR>
<DIV CLASS="center"><I>include-decl</I> ::= <TT>INCLUDE</TT>
 <I>string-const</I> <TT>;</TT></DIV><BR>
<BR>
<!--TOC subsection Statements-->

<H3 CLASS="subsection"><A NAME="htoc12">3.3</A>&nbsp;&nbsp;Statements</H3><!--SEC END -->

<A NAME="sec:syntax:statements"></A>
A statement is an if statement, a while statement, a set statement, a
call statement, and increment statement, a decrement statement, return
statement, or a block statement:<BR>
<BR>
<DIV CLASS="center"><I>stmt</I> ::= <I>if-stmt</I> | <I>while-stmt</I>
 | <I>set-stmt</I> | <I>call-stmt</I> |
 <I>incr-stmt</I> | <I>decr-stmt</I> |
 <I>return-stmt</I> | <I>block-stmt</I> </DIV><BR>
<BR>
<B>If statements.</B> An if statement consists of the keyword
<TT>IF</TT>, a conditional expression enclosed in parentheses, a
statement to execute if the condition is true, and optionally the
keyword <TT>ELSE</TT> followed by a statement to execute if the condition
is false:<BR>
<BR>
<DIV CLASS="center"><I>if-stmt</I> ::= <TT>IF</TT> <TT>(</TT> <I>expr</I> <TT>)</TT>
 <I>stmt [</I> <TT>ELSE</TT> <I>stmt ]</I></DIV><BR>
<BR>
<B>While statements.</B> A while statement consists of the keyword
<TT>WHILE</TT>, a test expression enclosed in parentheses, and a
statement to execute as long as the condition is true:<BR>
<BR>
<DIV CLASS="center"><I>while-stmt</I> ::= <TT>WHILE</TT> <TT>(</TT> <I>expr</I>
 <TT>)</TT> <I>stmt</I></DIV><BR>
<BR>
<B>Set statements.</B> A set statement consists of the keyword
<TT>SET</TT>, an expression, an equals sign, a right-hand-side
expression, and a terminating semicolon:<BR>
<BR>
<DIV CLASS="center"><I>set-stmt</I> ::= <TT>SET</TT> <I>expr</I> <TT>=</TT>
 <I>expr</I> <TT>;</TT></DIV><BR>
<BR>
The left-hand side expression may not be a binary operation <TT>=</TT>.<BR>
<BR>
<B>Call statements.</B> A call statement consists of a call
expression followed by a terminating semicolon:<BR>
<BR>
<DIV CLASS="center"><I>call-stmt</I> ::= <I>call-expr</I> <TT>;</TT></DIV><BR>
<BR>
<B>Increment statements.</B> An increment statement consists of the
keyword <TT>INCR</TT>, an expression, and a terminating semicolon:<BR>
<BR>
<DIV CLASS="center"><I>incr-stmt</I> ::= <TT>INCR</TT> <I>expr</I> <TT>;</TT></DIV><BR>
<BR>
<B>Decrement statements.</B> n decrement statement consists of the
keyword <TT>DECR</TT>, an expression, and a terminating semicolon:<BR>
<BR>
<DIV CLASS="center"><I>decr-stmt</I> ::= <TT>DECR</TT> <I>expr</I> <TT>;</TT></DIV><BR>
<BR>
<B>Return statements.</B> A return statement consists of the keyword
<TT>RETURN</TT>, an optional expression, and a terminating semicolon:<BR>
<BR>
<DIV CLASS="center"><I>return-stmt</I> ::= <TT>RETURN</TT> <I>[ expr ]</I>
 <TT>;</TT></DIV><BR>
<BR>
<B>Block statements.</B> A block statement consists of zero or more
statements enclosed in braces:<BR>
<BR>
<DIV CLASS="center"><I>block-stmt</I> ::= <TT>{</TT> <I>stmt</I><SUP>*</SUP>
 <TT>}</TT></DIV><BR>
<BR>
<!--TOC subsection Expressions-->

<H3 CLASS="subsection"><A NAME="htoc13">3.4</A>&nbsp;&nbsp;Expressions</H3><!--SEC END -->

<A NAME="sec:syntax:expressions"></A>
An expression is an identifier, an indexed expression, a register
expression, a numeric constant, a call expression, a binary operation
expression, a unary operation expression, or a parentheses expression.<BR>
<BR>
<DIV CLASS="center"><I>expr</I> ::= <I>identifier</I> |
 <I>indexed-expr</I> | <I>register-expr</I> |
 <I>numeric-const</I> | <I>call-expr</I> |
 <I>binop-expr</I> | <I>unop-expr</I> |
 <I>parens-expr</I>
</DIV><BR>
<BR>
Except for binary expressions as specified below, any ambiguity in
parsing is resolved using right recursion. For example, <TT>@F()</TT> is
parsed as <TT>@(F())</TT> and not <TT>(@F)()</TT>.<BR>
<BR>
<B>Numeric constants.</B> A numeric constant is an integer or
character constant:<BR>
<BR>
<DIV CLASS="center"><I>numeric-const</I> ::= <I>integer-const</I> |
 <I>char-const</I></DIV><BR>
<BR>
<B>Call expressions.</B> A call expression consists of an expression
followed by an argument list enclosed in parentheses:<BR>
<BR>
<DIV CLASS="center"><I>call-expr</I> ::= <I>expr</I> <TT>(</TT>
 <I>[ expr (</I> <TT>,</TT> <I>expr )</I><SUP>*</SUP> <I>]</I> <TT>)</TT></DIV><BR>
<BR>
<B>Indexed expressions.</B> An indexed expression consists of a
base expression, an offset expression, and a size:<BR>
<BR>
<DIV CLASS="center"><I>indexed-expr</I> ::= <I>expr</I> <TT>[</TT>
 <I>expr</I> <TT>,</TT> <I>size</I> <TT>]</TT></DIV><BR>
<BR>
<B>Register expressions.</B> A register expression consists of a
caret character followed by a 6502 register name:<BR>
<BR>
<DIV CLASS="center"><I>register-expr</I> ::= <TT>^</TT> <I>(</I> <TT>A</TT> |
 <TT>X</TT> | <TT>Y</TT> | <TT>P</TT> | <TT>S</TT> <I>)</I></DIV><BR>
<BR>
<B>Binary operation expressions.</B> A binary operation expression
consists of a left-hand-side expression, a binary operator, and a
right-hand-side expression:<BR>
<BR>
<DIV CLASS="center"><I>binop-expr</I> ::= <I>expr binop expr</I></DIV>
<DIV CLASS="center"><I>binop</I> ::= <TT>&gt;</TT> | <TT>&lt;</TT> | <TT>&lt;=</TT> |
 <TT>&gt;=</TT> | <TT>AND</TT> | <TT>OR</TT> | <TT>XOR</TT> | <TT>+</TT> |
 <TT>-</TT> | <TT>*</TT> | <TT>/</TT> | <TT>&lt;&lt;</TT>&nbsp;| <TT>&gt;&gt;</TT>&nbsp;|
 <TT>=</TT></DIV><BR>
<BR>
Parsing of binary operation expressions is disambiguated using the
following precedence rules:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
In any sequence <I>expr-1 binop-1
 expr-2 binop-2 expr-3</I>, the implied
 parentheses go around the first operation unless the second
 operation has a strictly higher precedence. There are five levels
 of precedence, from highest to lowest: (1) <TT>&lt;&lt;</TT> and <TT>&gt;&gt;</TT>;
 (2) <TT>*</TT> and <TT>\</TT>; (3) <TT>+</TT> and <TT>-</TT>; (4) <TT>=</TT>,
 <TT>&gt;</TT>, <TT>&lt;</TT>, <TT>&lt;=</TT>, and <TT>&gt;=</TT>; and (5) <TT>AND</TT>,
 <TT>OR</TT>, and <TT>XOR</TT>.
<LI CLASS="li-enumerate">Binary operators bind more weakly than any other expression
 combinators. For example, <TT>A+B()</TT> is parsed as <TT>A+(B())</TT>
 and not <TT>(A+B)()</TT>; and <TT>-5+3</TT> is parsed as <TT>(-5)+3</TT> and
 not <TT>-(5+3)</TT>.
</OL>
<B>Unary operation expressions.</B> A unary operation expression
consists of a unary operator followed by an expression:<BR>
<BR>
<DIV CLASS="center"><I>unop-expr</I> ::= <I>unop expr</I></DIV><BR>
<BR>
<DIV CLASS="center"><I>unop</I> ::= <TT>@</TT> | <TT>NOT</TT> | <TT>-</TT></DIV><BR>
<BR>
<B>Parentheses expressions.</B> A parentheses expression is an
expression surrounded by parentheses:<BR>
<BR>
<DIV CLASS="center"><I>parens-expr</I> ::= <TT>(</TT> <I>expr</I> <TT>)</TT></DIV><BR>
<BR>
<!--TOC section Semantic Checking-->

<H2 CLASS="section"><A NAME="htoc14">4</A>&nbsp;&nbsp;Semantic Checking</H2><!--SEC END -->

<A NAME="sec:semantics"></A>
The compiler checks every source file for conformance to the semantic
rules stated below. A semantically invalid program (i.e., one that
violates one of these rules) generates a compile-time error and causes
compilation to halt. Only semantically valid files go on to code
generation as described in Section&nbsp;<A HREF="#sec:code-gen">5</A>.<BR>
<BR>
<!--TOC subsection Representation of Values-->

<H3 CLASS="subsection"><A NAME="htoc15">4.1</A>&nbsp;&nbsp;Representation of Values</H3><!--SEC END -->

<A NAME="sec:semantics:values"></A>
The AppleCore language supports two types of values: integer values
and Boolean values.<BR>
<BR>
<B>Integer values.</B> Integer values are represented in AppleCore
in the ordinary way for the Apple II:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Unsigned single-byte values are represented by treating the 8
 bits, low to high, as the 8 digits of a binary number.
<LI CLASS="li-enumerate">Multi-byte values are stored in little-endian order.
<LI CLASS="li-enumerate">Signed values are stored in two's complement representation
 (i.e., by constructing the absolute value of the number, flipping
 the bits, and adding one).
</OL>
<B>Boolean values.</B> The AppleCore language has no special Boolean
type; as in C, ordinary integers serve as Boolean values. However,
AppleCore differs from C in what values it treats as &#8220;true&#8221; and
&#8220;false.&#8221; In AppleCore, only the lowest-order bit is relevant in
testing the Boolean value of an integer: integers whose low bit is 1
(i.e., odd integers) all count as &#8220;true,&#8221; while integers whose low
bit is 0 (i.e., even integers) all count as &#8220;false.&#8221; This mechanism
allows bitwise <TT>NOT</TT> to function as logical <TT>NOT</TT>, without any
need for a separate logical negation operator, and that keeps the
language simple. Also, the constants 1 and 0 can function as &#8220;true&#8221;
and &#8220;false.&#8221; These names and values are not built into the
language, but one can easily declare constants <TT>TRUE</TT> and
<TT>FALSE</TT> with the values 1 and 0.<BR>
<BR>
<!--TOC subsection Attribution-->

<H3 CLASS="subsection"><A NAME="htoc16">4.2</A>&nbsp;&nbsp;Attribution</H3><!--SEC END -->

<A NAME="sec:semantics:attr"></A>
The first semantic check performed by the compiler is to match each
identifier appearing in the source file with its corresponding
definition; this step is called <EM>attribution</EM>. For purposes of
these rules, a <EM>definition</EM> is a constant declaration, data
declaration, variable declaration, function parameter declaration, or
function declaration. A <EM>use</EM> is any identifier appearing in the
source file not as the identifier of a definition.<BR>
<BR>
The compiler matches definitions with uses in the following way:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
At global scope (i.e., outside of any function body), for each
 use find the corresponding definition with the same identifier at
 global scope. If there is no corresponding definition, or if any
 two definitions use the same identifier, then report an error.
<LI CLASS="li-enumerate">At function scope (i.e., inside a function body), for each use
 find the corresponding definition with the same identifier in the
 function scope, which consists of the global scope together with all
 function parameters and local variables declared in the function.
 If there is no corresponding definition, or if any two definitions
 in the function scope use the same identifier, then report an error.
</OL>
Constant declarations must precede their uses in the source file.
Otherwise, declarations need not precede their uses.<BR>
<BR>
<!--TOC subsection Constant-Value Expressions-->

<H3 CLASS="subsection"><A NAME="htoc17">4.3</A>&nbsp;&nbsp;Constant-Value Expressions</H3><!--SEC END -->

<A NAME="sec:semantics:constant-value-expr"></A>
A constant-value expression is one of the following:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
A numeric constant.
<LI CLASS="li-enumerate">An identifier corresponding to a constant declaration.
<LI CLASS="li-enumerate">A binary operation expression, where each operand is a
 constant-value expression.
<LI CLASS="li-enumerate">A negation (<TT>-</TT>) or <TT>NOT</TT> unary operation expression,
 where the operand is a constant-value expression.
<LI CLASS="li-enumerate">A parentheses expression, where the expression inside the
 parentheses is a constant-value expression.
</OL>
<!--TOC subsection Expressions Appearing at Global Scope-->

<H3 CLASS="subsection"><A NAME="htoc18">4.4</A>&nbsp;&nbsp;Expressions Appearing at Global Scope</H3><!--SEC END -->

<A NAME="sec:semantic:global-expr"></A>
An expression appearing at global scope (i.e., in a constant or data
declaration, or as the initializer of a global variable declaration)
must be one of the following:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
A constant-value expression
 (Section&nbsp;<A HREF="#sec:semantics:constant-value-expr">4.3</A>).
<LI CLASS="li-enumerate">An identifier corresponding to a data declaration (useful for
 data tables).
<LI CLASS="li-enumerate">An identifier corresponding to a function declaration (useful
 for jump tables).
</OL>
These rules are designed so that the compiler can do a single pass
over all the expressions <I>expr</I> appearing at global scope, in
the order in which they appear in the source file, and either compute
the value of <I>expr</I> (in case 1) or generate an assembler label
for <I>expr</I> (in cases 2 and 3). In case 3, the actual address
associated with the assembler label may not be known until final
assembly (Section&nbsp;<A HREF="#sec:code-gen:source-files">5.1</A>).<BR>
<BR>
<!--TOC subsection Size and Signedness-->

<H3 CLASS="subsection"><A NAME="htoc19">4.5</A>&nbsp;&nbsp;Size and Signedness</H3><!--SEC END -->

<A NAME="sec:semantics:size"></A>
<B>Size and signedness of expressions.</B> Every expression
appearing in the source file is given a <EM>size</EM> and a
<EM>signedness</EM>. The size and signedness of a constant-value
expression (Section&nbsp;<A HREF="#sec:semantics:constant-value-expr">4.3</A>) come from
the value produced by evaluating the expression as specified in
Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A>, assuming that both operands
have the maximum allowed size of 255. The size is the minimum number
of bytes required to represent the value. The expression is signed if
the value is less than zero, otherwise unsigned.<BR>
<BR>
For an expression that is not a constant-value expression, size and
signedness are computed as follows:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<I>Identifiers.</I> The size and signedness of an identifier
 come from its definition (Section&nbsp;<A HREF="#sec:semantics:attr">4.2</A>). (1) If
 the definition is a variable declaration or function parameter
 declaration, then the size is as given in the declaration, and the
 signedness is signed if <TT>S</TT> appears after the size, otherwise
 unsigned. (2) If the definition is a data declaration or function
 declaration, then the size is 2, and the signedness is unsigned.
<LI CLASS="li-itemize"><I>Indexed expressions.</I> The size of an indexed expression
 is given by the <I>size</I> component of the expression. It is
 always unsigned. 
<LI CLASS="li-itemize"><I>Register expressions.</I> The size of a register expression
 is 1. It is unsigned.
<LI CLASS="li-itemize"><I>Call expressions.</I> If the called expression (i.e., the
 expression before the first parenthesis) is anything other than an
 identifier corresponding to a function declaration, then the size is
 0 and the signedness is unsigned. Otherwise the size and signedness
 come from the function declaration corresponding to the identifier:
 (1) If a <I>size</I> appears after the keyword <TT>FN</TT> in the
 definition, then that is the return size; otherwise the return size
 is 0. (2) If <TT>S</TT> appears after <I>size</I> then the
 signedness is signed, otherwise unsigned.
<LI CLASS="li-itemize"><I>Binary operation expressions.</I> For comparison
 operations, the size is 1 byte unsigned. For shift operations, the
 size and signedness come from the left operand. For all other
 operations, the size is the maximum of the sizes of its operands.
 If either of the operands is signed, then the result is signed.
 Otherwise, the result is unsigned.
<LI CLASS="li-itemize"><I>Unary operation expressions.</I> The size and signedness of
 a unary operation expression come from the operand, except that (1)
 an address operation <TT>@</TT> is two bytes unsigned; and (2) a
 negation operation is signed.
<LI CLASS="li-itemize"><I>Parentheses expressions.</I> The size and signedness of a
 parentheses expression come from the enclosed expression.
</UL>
<B>Size and signedness requirements for expressions.</B> The
following requirements apply to the size and signedness of all
 expressions, whether or not they are constant-value expressions:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<I>Indexed expressions.</I> Both the base expression (before
 the first bracket) and the index expression (immediately after the
 first bracket) must have size 1 or 2.
<LI CLASS="li-itemize"><I>Call expressions.</I> (1) The called expression must be an
 expression of size 1 or 2. (2) Each argument expression must have
 nonzero size.
<LI CLASS="li-itemize"><I>Binary operation expressions.</I> For shift operations,
 the right-hand expression must be 1 byte unsigned.
</UL>
<B>Set statements.</B> The right-hand expression of a set statement
must have nonzero size.<BR>
<BR>
<B>Return statements.</B> (1) No return statement may contain an
expression of zero size. (2) If a function has nonzero return size,
and the function has a body, then (a) the body must end with a return
statement containing an expression, and (b) every return statement
appearing in the body must contain an expression. (3) If a function
has return size 0, then no return statement in the function body may
contain an expression.<BR>
<BR>
<B>Function frame sizes.</B> The <EM>frame size</EM> of a function
declaration that contains a body equals the sum of the sizes of all
the function parameters and local variables. No function may have a
frame size of greater than 255 bytes.<BR>
<BR>
<!--TOC subsection Number of Function Arguments-->

<H3 CLASS="subsection"><A NAME="htoc20">4.6</A>&nbsp;&nbsp;Number of Function Arguments</H3><!--SEC END -->

<A NAME="sec:semantics:fn-args"></A>
At every call expression where the called expression is an identifier
corresponding to a function declaration, the number of arguments must
match the number of parameters given in the declaration.<BR>
<BR>
<!--TOC subsection Semantic LValues-->

<H3 CLASS="subsection"><A NAME="htoc21">4.7</A>&nbsp;&nbsp;Semantic LValues</H3><!--SEC END -->

<A NAME="sec:semantics:lvalues"></A>
<B>Definition of semantic lvalue.</B> A <EM>semantic lvalue</EM> is
an expression that (1) is an identifier, register expression, or
indexed expression; and (2) if it is an identifier, then it
corresponds to a variable or function parameter declaration.<BR>
<BR>
<B>Requirement of semantic lvalues.</B> (1) A semantic lvalue is
required in the following places: (a) on the left-hand side of a set
statement; (b) as the expression of an increment or decrement
statement; and (c) as the operand of an address (<TT>@</TT>) unary
operator. If an expression that is not a semantic lvalue appears in
any of these places, then a compile-time error results. (2) A
compile-time error results if a register expression appears as the
operand of an address (<TT>@</TT>) operator.<BR>
<BR>
<!--TOC section Code Generation-->

<H2 CLASS="section"><A NAME="htoc22">5</A>&nbsp;&nbsp;Code Generation</H2><!--SEC END -->

<A NAME="sec:code-gen"></A>
<!--TOC subsection Source Files-->

<H3 CLASS="subsection"><A NAME="htoc23">5.1</A>&nbsp;&nbsp;Source Files</H3><!--SEC END -->

<A NAME="sec:code-gen:source-files"></A>
The AppleCore language is designed to support separate compilation.
To do that, the compiler translates source files to assembly files in
one of two modes: <EM>top-level mode</EM> and <EM>include mode</EM>. The
mode must be specified at the time the source file is translated to
assembly, usually as a compiler option.<BR>
<BR>
<B>Top-level mode.</B> In top-level mode, the compiler translates
the source file as follows:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Issue some code (or an assembler directive to include the code)
 that sets up the program stack
 (Section&nbsp;<A HREF="#sec:code-gen:program-stack">5.3</A>).
<LI CLASS="li-enumerate">Issue code to transfer control to the first function with a body
 that appears in the file. There must be at least one such function,
 and it is a compile-time error if not.
<LI CLASS="li-enumerate">Translate all global declarations in the source file as
 described in Section&nbsp;<A HREF="#sec:code-gen:global-decls">5.2</A>, in the
 order in which they appear in the source file. Include declarations
 may appear anywhere in the file, and they are translated to
 directives to include the corresponding assembly files.
<LI CLASS="li-enumerate">Issue assembler directives to include the AppleCore support code
 (for example, the code needed to do arithmetic operations).
</OL>

<B>Include mode.</B> In include mode, the compiler just translates
the declarations in the source file as described in
Section&nbsp;<A HREF="#sec:code-gen:global-decls">5.2</A>. In include mode, the source
program may not contain any include directives, and it is a
compile-time error for one to appear.<BR>
<BR>
<B>Final assembly and symbol resolution.</B> A user program consists
of exactly one file translated in top-level mode and zero or more
files translated in include mode. The final step in compilation is to
ask the assembler to assemble the file translated in top-level mode,
which includes all the other files for assembly. This assembly also
causes name resolution for externally defined functions. It is the
user's responsibility to ensure that externally-defined names are both
available and uniquely defined; the compiler cannot check this. If a
symbol used in one of the assembled files is not defined in any of the
files (or if any symbol is multiply defined), then an assembler error
will result.<BR>
<BR>
<!--TOC subsection Global Declarations-->

<H3 CLASS="subsection"><A NAME="htoc24">5.2</A>&nbsp;&nbsp;Global Declarations</H3><!--SEC END -->

<A NAME="sec:code-gen:global-decls"></A>
Global declarations are translated as stated below. To the extent
that translation produces actual bytes of machine code, data, or
reserved storage, the bytes must be laid out in the order in which the
translated constructs are encountered in the source file.<BR>
<BR>
<B>Constant declarations.</B> The compiler (1) evaluates the
expression of the constant declaration to a numeric constant according
to the rules in Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A> and (2)
associates this value with the name given in the constant declaration.
The compilation must support the use of the same identifier for
different constant declarations in different files that are part of
the same final assembly (Section&nbsp;<A HREF="#sec:code-gen:source-files">5.1</A>).<BR>
<BR>
<B>Data declarations.</B> (1) If an expression appears before the
semicolon, then the compiler evaluates the expression to a numeric
constant according to the rules in
Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A> and generates code to store the
bytes of the constant in little-endian order. (2) If a string
constant appears before the semicolon, then the compiler generates
assembly code to store the bytes of the string constant in
left-to-right order. (a) If no backslash <TT>\</TT> follows the string
constant, then the compiler adds a terminating NUL ($00) character
after the last byte of string data. (b) If a backslash follows the
string constant, then no NUL character is added. (3) In any case, if
an identifier appears after the keyword <TT>DATA</TT>, then the compiler
associates the name with the lowest address in which data is stored.<BR>
<BR>
<B>Global variable declarations.</B> The compiler sets aside a
number of bytes of storage equal to the declared size of the variable
and associates the identifier appearing after <TT>VAR</TT> with the
lowest address of this storage. If an expression appears before the
semicolon, then the compiler evaluates the expression to a numeric
constant according to the rules stated in
Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A> and issues assembly code to
fill in the storage set aside for the variable with the bytes of the
numeric constant, in little-endian order, using size adjustment (if
necessary) as stated in Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>.<BR>
<BR>
<B>Function declarations.</B> (1) A function declaration with no
body does not correspond to any generated code; its signature is used
only for checking call expressions that invoke the function. (2) A
function declaration with a body causes code to be generated as stated
in Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>.<BR>
<BR>
<B>Include declarations.</B> In top-level mode (see
Section&nbsp;<A HREF="#sec:code-gen:source-files">5.1</A>), the compiler translates an
include declaration into an assembler directive to include the file
named in the string constant. In include mode, the presence of an
include declaration in the source file causes an error.<BR>
<BR>
<!--TOC subsection Program Stack-->

<H3 CLASS="subsection"><A NAME="htoc25">5.3</A>&nbsp;&nbsp;Program Stack</H3><!--SEC END -->

<A NAME="sec:code-gen:program-stack"></A>
This specification requires that the implementation provide three
logical stacks for use at runtime, collectively referred to as the
<EM>program stack</EM>:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
A C-style <EM>call stack</EM>, such that a new frame appears at
 the top of the stack for each function call, and the frame is popped
 at the end of the call. This stack is used in generating function
 call code, as specified in Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>.
<LI CLASS="li-enumerate">An <EM>expression stack</EM> for use during expression evaluation
 as specified in Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A>.
<LI CLASS="li-enumerate">An <EM>allocation stack</EM> that supports an <TT>ALLOCATE</TT>
 library function that works as follows. (1) <TT>ALLOCATE</TT> is only
 ever called when no temporary expression result is on the expression
 stack; otherwise the results are undefined. (2) When <TT>ALLOCATE</TT>
 is called, it is passed a two-byte size value <I>s</I>. (3) (a) If there
 is enough space on the stack, then <TT>ALLOCATE</TT> returns a pointer
 to <I>s</I> bytes on the stack. (b) If there are not <I>s</I> bytes remaining
 on the stack, then the results are undefined. (4) The <I>s</I> bytes
 pointed to by the result of the <TT>ALLOCATE</TT> call remain valid
 (i.e., are not modified except by user-written code) during the
 lifetime of the call stack frame for the function in which the
 <TT>ALLOCATE</TT> call occurred. (5) At the end of the function in
 which the <TT>ALLOCATE</TT> call occurred, the memory is deallocated
 and may be reused as program stack storage.
</OL>
The compiler may provide this stack functionality in any way that is
feasible. Typically the same physical stack would be used for all
three logical stacks (and the logical stacks have been specified so
that this is possible), but this is not a requirement. Also,
typically the generated code would maintain its own two-byte stack
pointer, because the native Apple II stack located at addresses $200
through $2FF is too small to serve as the program stack for this
language. However, this specification does not mandate any particular
stack size; the actual available stack size depends on both the
compiler implementation and the program memory requirements (for
example, whether the graphics and/or language card areas are available
for program heap and stack data).<BR>
<BR>
<!--TOC subsection Function Bodies-->

<H3 CLASS="subsection"><A NAME="htoc26">5.4</A>&nbsp;&nbsp;Function Bodies</H3><!--SEC END -->

<A NAME="sec:code-gen:fn-bodies"></A>
The AppleCore language definition assumes a C-style function call
stack as specified in Section&nbsp;<A HREF="#sec:code-gen:program-stack">5.3</A>. For
each function declaration that has a body, the compiler does the
following:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Generate code to store the callee's frame pointer on the call
 stack.
<LI CLASS="li-itemize">Generate code to reserve slots on the call stack for the
 function parameters, local variables, and saved registers. The
 saved registers are all the registers appearing in register
 expressions in the function body.
<LI CLASS="li-itemize">For each local variable declaration that includes an initializer
 expression, generate code to evaluate the expression according to
 the rules in Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A> and assign the
 resulting value into the stack slot for the variable, using size
 adjustment (if necessary) as stated in
 Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>.
<LI CLASS="li-itemize">For each statement of the function body, generate code as stated
 in Section&nbsp;<A HREF="#sec:code-gen:statements">5.5</A>. The statements of a
 function body are executed in sequence, in the order in which they
 appear in the program text.
<LI CLASS="li-itemize">If the last statement executed in the function is not a return
 statement, then generate code to pop the frame off the stack and
 restore the parent frame.
</UL>
This calling convention is designed so that from the point of view of
the caller, a call to an AppleCore function that takes no arguments
and returns no result is indistinguishable from a <TT>JSR</TT> to a
non-AppleCore function (for example, in the System Monitor). That
way, non-AppleCore assembly language functions can be called in the
same way as AppleCore functions. In particular, if <TT>V</TT> is a
variable, then a call expression <TT>V()</TT> has the same meaning
regardless of what kind of function address is stored in <TT>V</TT>
(which is not generally known at compile time). Also, a source file
with a function declaration <TT>FN FOO();</TT> can be assembled with any
assembly file containing a function with label <TT>FOO</TT>, regardless
of whether the code at label <TT>FOO</TT> uses the AppleCore conventions
for managing the stack.<BR>
<BR>
<!--TOC subsection Statements-->

<H3 CLASS="subsection"><A NAME="htoc27">5.5</A>&nbsp;&nbsp;Statements</H3><!--SEC END -->

<A NAME="sec:code-gen:statements"></A>
The compiler generates code to do the following for each program
statement.<BR>
<BR>
<B>If statements.</B> Evaluate the conditional expression
(Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A>), pop the result off the
expression stack, and mask off all but the lowest bit of the result to
get the corresponding Boolean value
(Section&nbsp;<A HREF="#sec:semantics:values">4.1</A>). If the Boolean value of the
result is 1 (true), then execute the true part. If the Boolean value
of the result is 0 (false), then either do nothing (if there is no
optional <TT>ELSE</TT> clause) or execute the statement in the <TT>ELSE</TT>
clause (if one is provided).<BR>
<BR>
<B>While statements.</B> Evaluate the conditional expression
(Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A>), pop the result off the
expression stack, and mask off all but the lowest bit of the result to
get the corresponding Boolean value
(Section&nbsp;<A HREF="#sec:semantics:values">4.1</A>). If the Boolean value of the
result is 1 (true), then execute the body of the loop and repeat the
whole process. If the Boolean value of the result is 0 (false), then
do nothing.<BR>
<BR>
<B>Set statements.</B> (1) Evaluate the right-hand side expression,
adjusting the size if necessary
(Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>) to conform to the size of
the left-hand side expression. (2) The left-hand side expression must
be a semantic lvalue (Section&nbsp;<A HREF="#sec:semantics:lvalues">4.7</A>). Compute
its address as specified in Section&nbsp;<A HREF="#sec:code-gen:lvalues">5.7</A>. (3)
Copy the result of step (1) into memory starting at the address
computed in step (2).<BR>
<BR>
<B>Call statements.</B> Evaluate the expression contained in the
statement (Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A>). If it produces a
result of nonzero size, pop the result off the stack.<BR>
<BR>
<B>Increment statements.</B> The operand expression must be a
semantic lvalue. (Section&nbsp;<A HREF="#sec:semantics:lvalues">4.7</A>). Compute its
address as stated in Section&nbsp;<A HREF="#sec:code-gen:lvalues">5.7</A>. Add one to
the value stored at the address and store the result in place.<BR>
<BR>
<B>Decrement statements.</B> The operand expression must be a
semantic lvalue. (Section&nbsp;<A HREF="#sec:semantics:lvalues">4.7</A>). Compute its
address as stated in Section&nbsp;<A HREF="#sec:code-gen:lvalues">5.7</A>. Subtract one
from the value stored at the address and store the result in place.<BR>
<BR>
<B>Return statements.</B> (1) If the statement contains an
expression, then evaluate the expression
(Section&nbsp;<A HREF="#sec:code-gen:expressions">5.6</A>) and ensure that it appears at
the top of the expression stack
(Section&nbsp;<A HREF="#sec:code-gen:program-stack">5.3</A>) on function return. (2)
Pop the current frame off the call stack and restore the parent frame.<BR>
<BR>
<B>Block statements.</B> Execute each statement of the block in the
order in which it appears in the program text.<BR>
<BR>
<!--TOC subsection Expressions-->

<H3 CLASS="subsection"><A NAME="htoc28">5.6</A>&nbsp;&nbsp;Expressions</H3><!--SEC END -->

<A NAME="sec:code-gen:expressions"></A>
We define the semantics of expressions using an expression stack, as
specified in Section&nbsp;<A HREF="#sec:code-gen:program-stack">5.3</A>. The compiler
generates code to do the following for each program expression.<BR>
<BR>
<B>Identifiers.</B> (1) If the identifier is a semantic lvalue
(Section&nbsp;<A HREF="#sec:semantics:lvalues">4.7</A>), then compute its address as
specified in Section&nbsp;<A HREF="#sec:code-gen:lvalues">5.7</A> and get a number of
bytes equal to the size of the right-hand side
(Section&nbsp;<A HREF="#sec:semantics:size">4.5</A>), starting at that address. Push
those bytes on the stack, using size adjustment if necessary
(Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>) to generate a result that
has a number of bytes equal to the left-hand expression size. (2) If
the identifier corresponds to a numeric constant declaration, then
push the bytes of the value associated with the declaration
(Section&nbsp;<A HREF="#sec:code-gen:global-decls">5.2</A>) on the stack in
little-endian order. (3) If the identifier corresponds to a data
declaration, then push the two-byte address associated with the
identifier (Section&nbsp;<A HREF="#sec:code-gen:global-decls">5.2</A>) on the stack in
little-endian order. (4) If the identifier corresponds to a function
declaration, then push the two-byte address corresponding to the first
byte of the function body (Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>) on
the stack in little-endian order. (If the function body is defined in
a different file, this can be done by using the label associated with
the function body; at assembly time, the label definition will be
available.)<BR>
<BR>
<B>Numeric constants.</B> Push the bytes of the value associated
with the declaration (Section&nbsp;<A HREF="#sec:code-gen:global-decls">5.2</A>) on the
stack in little-endian order.<BR>
<BR>
<B>Indexed expressions.</B> (1) Compute the address of the indexed
expression as stated in Section&nbsp;<A HREF="#sec:code-gen:lvalues">5.7</A>. (2) Get a
number of bytes equal to the size specified in the expression,
starting at that address, and push them on the stack.<BR>
<BR>
<B>Register expressions.</B> Push the one-byte value stored in the
function call stack slot for that register
(Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>) on the expression stack.<BR>
<BR>
<B>Call expressions.</B> The procedure depends on the kind of the
called expression.<BR>
<BR>
<I>(1) Declared functions:</I> If the called expression is an
identifier corresponding to a function declaration, then do the
following. (a) Evaluate each argument and store it to its slot on the
stack in the new frame, adjusting the argument sizes
(Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>) as necessary to them to
the parameter sizes specified in the function definition. (b) Adjust
the stack pointer to point to the base of the new frame. (c) Restore
all the saved registers (Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>) to the
values saved in their slots on the stack. (d) Do a <TT>JSR</TT> to the
code for the function body (Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>). (e)
Save all the saved registers to their slots.<BR>
<BR>
<I>(2) Compile-time constants:</I> If the called expression
evaluates to a compile-time constant, then (a) restore the registers
as in (1)(c), (b) <TT>JSR</TT> to the constant address, and (c) save the
registers as in (1)(e).<BR>
<BR>
<I>(3) Callee address unknown:</I> Otherwise the callee address is
not known at compile time. In this case proceed as in case 2, but in
step (2)(b) store the value to zero-page memory and do a <TT>JSR</TT> to
an indirect <TT>JMP</TT> to the address.<BR>
<BR>
The rules are designed so that in all cases the last value written
into the stack slot for each saved register prior to the call is
guaranteed to be in the corresponding 6502 register just before the
<TT>JSR</TT> to the called function. Thus, except for the <TT>S</TT>
register, all saved registers are guaranteed to have their saved
values at the point where control enters the callee function. Because
of the <TT>JSR</TT>, the <TT>S</TT> register's value will be increased by 2.
Similarly, all stack slots corresponding to saved registers other than
the <TT>S</TT> register will contain the values that the corresponding
registers had on exit from the function; the <TT>S</TT> register's value
will be off by 2.<BR>
<BR>
<B>Binary operation expressions.</B> <I>Shift operations
 (<TT>&lt;&lt;</TT>&nbsp;and <TT>&gt;&gt;</TT>).</I> Evaluate the left-hand side, evaluate the
right-hand side, pop the right-hand side, and shift the left-hand side
value (which is the result on the top of the stack) by a number of
bytes equal to the right-hand side value. In the case of a right
shift, the shift is signed (arithmetic) if the left-hand side
expression is signed; otherwise it is unsigned (logical).<BR>
<BR>
<I>Arithmetic operations (<TT>*</TT>, <TT>/</TT>, <TT>+</TT>, and
 <TT>-</TT>).</I> Evaluate the left and right expressions, adjust their
size if necessary (Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>) to make
their sizes equal to the size of the entire expression, pop the
results, perform the operation, and push the result. In the case of
multiplication and division, the operation is signed if the entire
expression is signed, otherwise unsigned. Because AppleCore uses
two's complement representation for negative numbers
(Section&nbsp;<A HREF="#sec:semantics:values">4.1</A>), there is no distinction between
signed and unsigned addition and subtraction. The division operation
produces the integer quotient. All operations are done without regard
to overflow (i.e., if overflow occurs, they produce the low-order
bits, up to the size of the expression).<BR>
<BR>
<I>Comparison operations (<TT>=</TT>, <TT>&gt;</TT>, <TT>&lt;</TT>, <TT>&gt;=</TT>,
 and <TT>&lt;=</TT>).</I> Evaluate the left and right expressions, adjust
their size if necessary (Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>)
to make their sizes equal to the size of the entire expression, pop
the results, perform the operation, and push the result. The result
is a single-byte value such that 1 represents true and 0 represents
false. In the case of comparisons other than equality, the operation
is signed if the entire expression is signed, otherwise unsigned.<BR>
<BR>
<I>Bitwise operations (<TT>AND</TT>, <TT>OR</TT>, and <TT>XOR</TT>).</I>
Evaluate the left and right expressions, adjust their size if
necessary (Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>) to make their
sizes equal to the size of the entire expression, pop the results,
perform the operation, and push the result.<BR>
<BR>
<B>Unary operation expressions.</B> <I>Dereference (<TT>@</TT>).</I>
The operand expression must be a semantic lvalue
(Section&nbsp;<A HREF="#sec:semantics:lvalues">4.7</A>). Compute and push its address
as stated in Section&nbsp;<A HREF="#sec:code-gen:lvalues">5.7</A>.<BR>
<BR>
<I>Arithmetic negation (<TT>-</TT>) and bitwise not (<TT>NOT</TT>).</I>
Evaluate the operand expression and perform the operation on it.
Negation is two's complement negation (i.e., <TT>NOT</TT> plus 1).<BR>
<BR>
<B>Parentheses expressions.</B> Evaluate the expression inside the
parentheses.<BR>
<BR>
<!--TOC subsection Address Computation for Semantic LValues-->

<H3 CLASS="subsection"><A NAME="htoc29">5.7</A>&nbsp;&nbsp;Address Computation for Semantic LValues</H3><!--SEC END -->

<A NAME="sec:code-gen:lvalues"></A>
Computation of the address of a semantic lvalue <I>expr</I> works
as follows:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
If <I>expr</I> is an identifier corresponding to a global
 variable, then its address is the lowest address of the global
 storage assigned to that variable
 (Section&nbsp;<A HREF="#sec:code-gen:global-decls">5.2</A>). 
<LI CLASS="li-enumerate">If <I>expr</I> is an identifier corresponding to a function
 parameter or local variable, then its address is the lowest address
 of the function call stack slot assigned to that parameter or
 variable (Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>).
<LI CLASS="li-enumerate">If <I>expr</I> is an indexed expression, then its address is
 computed by evaluating the base expression, evaluating the offset
 expression, popping and adding the results, and adjusting the size
 of the result to 2 if necessary
 (Section&nbsp;<A HREF="#sec:code-gen:size-adjustment">5.8</A>). 
<LI CLASS="li-enumerate">If <I>expr</I> is a register expression, then its address is
 the address of the function call stack slot assigned to that
 register (Section&nbsp;<A HREF="#sec:code-gen:fn-bodies">5.4</A>).
</OL>
<!--TOC subsection Size Adjustment-->

<H3 CLASS="subsection"><A NAME="htoc30">5.8</A>&nbsp;&nbsp;Size Adjustment</H3><!--SEC END -->

<A NAME="sec:code-gen:size-adjustment"></A>
<EM>Size adjustment</EM> applies whenever a result is assigned into or
out of a semantic lvalue and the sizes of the source and target values
do not match. The following rules apply to size adjustment:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
If the source value size is greater than the target value size,
 then high-order bytes of the source value are <EM>truncated</EM>: only
 the low-order bytes of the source value are stored, up to the number
 of bytes required by the target value.
<LI CLASS="li-enumerate">If the source value size is smaller than the target value size,
 and the source value is unsigned, then the source value is
 <EM>zero extended</EM>: the bytes of the source value form the
 low-order bytes of the target value, and zeros are used to fill the
 rest of the bytes of the target value.
<LI CLASS="li-enumerate">If the source value size is smaller than the target value size,
 and the source value is signed, then the source value is <EM>sign
 extended</EM>: the bytes of the source value form the low-order bytes
 of the target value, and the rest of the bytes of the target value
 are filed with either all 0 bits (if the high-order bit of the
 source value is 0) or all 1 bits (if the high-order bit of the
 source value is 1).
</OL>
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
<A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A>.</EM></BLOCKQUOTE></BODY>
</HTML>
