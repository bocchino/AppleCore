Things to check:

1. Every use of a name must correspond to a declaration.

2. Sizes

   a. Every expression has a size and a signedness.  These must be
      computed prior to code generation.

   b. Different sizes and signednesses can be freely assigned to each
      other without any errors or warnings.  Assigning a bigger thing
      to a smaller thing drops the high-order bytes.  Assiging a
      smaller thing to a bigger thing leaves the high-order bytes
      unchanged.  For example, if VAR1[0,4] is 1,2,3,4 (low- to
      high-order) and VAR2[0,2] is 5,6, then SET VAR1[0,2]=VAR2[0,4]
      puts 1,2 in VAR2[0,2], while SET VAR1[0,4]=VAR2[0,2] puts
      5,6,3,4 in VAR1[0,4].

   c. Only one- or two-byte unsigned values can be indexed.

   d. ADDRESS declarations must be one-or two-byte values.

3. Lvalues

   a. The parser admits some syntactic "lvalues" (like constant
      labels) that aren't actual lvalues.  Only variables and indexed
      expressions can be lvalues.

   b. The LHS of a SET expression must be an lvalue.  The operand of
      an INCR or DECR expression must be an lvalue.

   c. Anything you take the address of must be an lvalue.  For
      example, you can't take the address of a constant, label, or
      function name.

4. In an expression statement, the expression must have an effect,
   i.e., be SET, CALL, INCR, or DECR.  This simple check traps the
   nasty error of writing X=2; (comparison) when you meant SET X=2;
   (assignment).

5. At function calls where a prototype is available, the number of
   args must match the number of params.


