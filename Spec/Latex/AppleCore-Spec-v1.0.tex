\documentclass[10pt]{article}

\input{defs}

\begin{document}

\title{\bfseries{The AppleCore Language Specification, v1.0}}
%
\author{Robert L. Bocchino Jr.\\
Pittsburgh, PA}
%
\date{Revised December 4, 2011}

\maketitle

\section{Introduction and Rationale}

AppleCore is a C-like programming language for the Apple II series of
computers.  A cross-compiler from Java (e.g., running on a Mac or PC)
to the Apple II is under development; the goal is eventually to write
an AppleCore compiler in AppleCore, thereby providing a compiler that
works on the Apple II.

The idea of AppleCore is to provide a ``core language for programming
the Apple II.''  The motivation is as follows:
%
\begin{enumerate}
%
\item Programming the Apple II is both nostalgic and just plain fun.
%
\item The Apple II is a small machine.  Therefore it needs a
  lightweight programming model (i.e., without complicated runtime
  overhead in space or time).  The programming model must also provide
  (1) tight control over the layout of generated code and (2) easy
  integration with assembly-language support routines such as those
  provided by the System Monitor or Applesoft.
%
\item The native programming models on the Apple II are inadequate.
  Assembly language is powerful but painfully low-level.  Applesoft,
  on the other hand, is a disaster.  It lacks even the most basic
  abstraction required of a sane programming environment, including
  scoped loops, scoped functions with local variables, and variable
  names longer than \emph{two letters}!  Applesoft does have nice
  support for numeric and string input and output, so if you just want
  to write short programs that read and write things, it's handy. But
  for any but the tiniest programs, Applesoft code becomes an
  unreadable mess.  In terms of control abstraction Applesoft is
  actually worse than assembly language, because it forces you to
  branch to numbered lines, whereas in assembly language you can
  \kwd{JMP} and \kwd{JSR} to symbolic labels with meaningful names.
%
\end{enumerate}

The goal of AppleCore is to rectify this situation by providing a
low-level language with some minimal programming abstractions that's
both useful and fun to program with.  First, it's a compiled language,
so it should run faster than Applesoft.  Second, it's modular and
supports separate compilation.  In particular, the entire core
language needs only a few kilobytes of support routines; additional
routines can be linked in as needed.  Third, AppleCore strikes a
balance between power and efficiency.  Notably, it supports integer
arithmetic on fixed-size variables of up to 255 bytes, so it
essentially gives arbitrary-precision arithmetic.  This power does
come at a cost in terms of speed for single-byte arithmetic that could
be done in registers; however, if that speed is needed, one can easily
call into assembly language arithmetic routines.  Fourth, it provides
easy integration with assembly language routines; in particular, you
can say things like ``load `A' into the accumulator and call \$FDED''
that are impossible to say in Applesoft or other high-level languages
without assembly-language wrapper code.

The main things that AppleCore lacks, and that Applesoft provides, are
automatic memory management and support for floating-point
computation.  I've left out memory management to keep things very
simple.  Basically, as a programmer I can't live happily without
control abstractions (loops and functions); but once I have them I'm
perfectly content to synthesize data abstractions on my own.  If this
becomes too much of a pain, a library for memory management can be
added without difficulty, after the fashion of C.  (Applesoft actually
provides garbage collection, but it works very poorly, causing the
machine to seize up when the memory limit is reached.)  I've left out
floating-point computation mainly because I'm most interested in text
processing and integer computations; but again, FP computations can be
added without too much difficulty.  In the mean time, one can fake FP
computations by encoding FP literals as string data and calling into
the Applesoft FP routines to convert from strings to FP numbers and
back, and to compute using the FP numbers.  Applesoft is actually
quite good at this.

\section{Lexical Structure}

Before parsing a source file, the source text is separated into
\emph{tokens}.  There are four classes of tokens: identifiers,
keywords, constants, and symbols.

\subsection{White Space}
\label{sec:lexical:white-space}

White space consists of any sequence of the following characters:
space (ASCII SP, value \$20), newline (ASCII NL, value \$0A), carriage
return (ASCII CR, value \$0D), and horizontal tab (ASCII HT, value
\$09).  Whitespace is always useful in formatting readable programs,
but it is syntactically irrelevant except in the following two cases:
%
\begin{enumerate}
%
\item \ithead{Separation of tokens.} When a whitespace character or end of
file appears immediately after a non-whitespace character, that
signifies the end of a token.
%
\item \ithead{End of line.} An end-of-line sequence (\kwd{EOL}) is a
  comment terminator (see Section~\ref{sec:lexical:comments}).  As
  usual, the definition of \kwd{EOL} is platform-dependent: on the
  Apple II it is CR, on UNIX it is NL, and on Windows it is CR
  followed by NL.
%
\end{enumerate}
%
The lexer may also count source lines (using \kwd{EOL}) to provide
line numbers for error messages.

\subsection{Identifiers}\label{Identifiers}

An identifier is a sequence of letters (including the underscore
character) and digits that is not a keyword.  The first character must
be a letter.  Upper and lower case letters are distinct.

\subsection{Keywords}

The following sequences of characters are reserved for use as keywords
and may not be used as identifiers:
\begin{ttfamily}
\begin{center}
\begin{tabular}{l l l l}
AND & CONST & DATA & DECR \\
%
ELSE & FN & IF & INCLUDE \\
%
INCR & NOT & OR & RETURN \\
%
SET & VAR & XOR & WHILE \\
\end{tabular}
\end{center}
\end{ttfamily}

Following Apple II tradition (mostly because the original Apple II had
no support for lower-case letters), AppleCore keywords are uppercase.
That means that the same words in lowercase (or a combination of
upper- and lowercase) are not recognized as keywords, so those
sequences of characters are availble for use as identifiers.

\subsection{Constants}
\label{sec:lexical:constants}

There are three types of constants: integer constants, string
constants, and character constants.  

\bfhead{Integer constants.}  Integer constants may be written in
decimal or hexadecimal form.  A decimal integer constant consists of
one or more decimal digits \kwd{0} through \kwd{9}.  For example,
\kwd{1} and \kwd{123} are valid integer constants in decimal form.  A
hexadecimal integer constant consists of a dollar sign \kwd{\$}
followed by by one or more hexadecimal digits \kwd{0} through \kwd{9}
or \kwd{A} through \kwd{F}.  For example, \kwd{\$1}, \kwd{\$A}, and
\kwd{\$00FF} are valid integer constants in hexadecimal form.

\bfhead{String constants.} A string constant is a sequence of
characters enclosed in double quotes (\kwd{"..."}).  A string constant
represents a sequence of ASCII characters, one for each character
appearing in the double-quotes, except that the character sequence
\kwd{\bs\$} has the special meaning described below.

Since not all ASCII characters have printable representations, an
\emph{escape sequence} may be used to represent an arbitrary ASCII
value (printable or non-printable).  An escape sequence consists of a
backslash \kwd{\bs} followed by a dollar sign \kwd{\$} and two
hexadecimal digits.  The whole sequence represents the single
character with the ASCII value given by the digits.  For example, the
string constant
%
$$\kwd{"Hello, world!\bs\$0D"}$$
%
represents a null-terminated string consisting of the characters
\kwd{Hello, world!} followed by a CR character.  Similarly, the quote
character \kwd{"} can be embedded in a string constant with the
sequence \kwd{\bs\$22}.

\bfhead{Character constants.} A character constant consists of a
single-quote character \kwd{'}, followed by a printable ASCII
character, followed by another single-quote character.  It represents
the ASCII value associated with the character.  For example, the
constant \kwd{'A'} represents the value $\$41$.

\subsection{Symbols}

AppleCore uses the symbols shown in Figure~\ref{fig:symbols}, each of
which is a separate token.

\begin{figure}[th]
\begin{center}
\begin{tabular}{c l}
\textbf{Symbol} & \textbf{Meaning} \\
%
\kwd{@} & Denotes the address of a variable \\
%
\kwd{\^} & Denotes a 6502 register expression \\
\kwd{*}  & Multiplication \\
\kwd{/}  & Division \\
\kwd{+}  & Addition \\
\kwd{-}  & Negation (as unary operator); subtraction (as binary
operator) \\
\kwd{<<} & Left shift \\
\kwd{>>} & Right shift \\
\kwd{>=} & Greater than or equal to \\
\kwd{<=} & Less than or equal to \\
\kwd{>}  & Greater than \\
\kwd{<}  & Less than \\
\kwd{=}  & Equal to; assignment \\
\kwd{(} and \kwd{)} & Encloses function parameters and arguments, parenthesized expressions
\\
\kwd{\{} and \kwd{\}} & Encloses statement blocks \\
\kwd{[} and \kwd{]} & Pointer dereference \\
\kwd{;} & Terminates declarations and statements \\
\kwd{:} & Separates variable declaration from size \\
\kwd{,} & Separates function parameters and arguments; separates index from size in dereference \\
\end{tabular}
\end{center}
\caption{Symbols used in AppleCore syntax.}
\label{fig:symbols}
\end{figure}

\subsection{Comments}
\label{sec:lexical:comments}

The character \kwd{\#} in the source file indicates a comment; all
text to the next end of line (or end of file, if there is no end of
line) are ignored by the lexer.  Multiline comments are indicated by
preceding each line with \kwd{\#}.

\section{Syntax}
\label{sec:syntax}

The syntax description below uses the following conventions:
%
\begin{itemize}
%
\item The symbol $^*$ denotes zero or more instances of the entity
  preceding it.
%
\item Italicized parentheses \group{} group the enclosed symbols and
  do not denote program text.
%
\item Italicized brackets \opt{} signify that the enclosed symbols are
  optional (i.e., they may occur zero or one time).  They do not
  denote program text.
%
\item The nonterminal \nonterm{identifier} stands for any identifier
  as defined in Section \ref{Identifiers}.
%
\item The nonterminals \nonterm{integer-const},
  \nonterm{string-const}, and \nonterm{char-const} stand for integer,
  string, and character constants as defined in
  Section~\ref{sec:lexical:constants}.
%
\item The nonterminal \nonterm{size} refers to an integer constant
  whose value is between 0 and 255 (inclusive).
%
\item Text and symbols in \kwd{typewriter} font (including
  non-italicized parentheses and brackets) denote literal program
  text.
%
\end{itemize}

\subsection{Source Files}
\label{sec:syntax:source-files}

The basic syntactic unit of an AppleCore program is a \emph{source
  file}, i.e., an input file provided to the AppleCore compiler for
compilation.  The compiler translates the source file into an assembly
file which is then linked with other assembly files as discussed in
Section~\ref{sec:code-gen:source-files} to form a complete executable
program.

An AppleCore source file is given by zero or more
declarations:
%
$$\nonterm{source-file} ::= \nonterm{decl}^*$$
%
A declaration is a constant declaration, a data declaration, a
variable declaration, a function declaration, or an include
declaration:
%
$$\nonterm{decl} ::= \mbox{\nonterm{const-decl} $|$
  \nonterm{data-decl} $|$ \nonterm{var-decl} $|$ \nonterm{fn-decl}
    $|$ \nonterm{include-decl}}$$

\subsection{Declarations}
\label{sec:syntax:declarations}

\bfhead{Constant declarations.} A constant declaration consists of the
keyword \kwd{CONST}, an identifier, an optional expression, and a
terminating semicolon:
%
$$\nonterm{const-decl} ::= \mbox{\kwd{CONST} \nonterm{identifier}
  \opt{\nonterm{expr}} \kwd{;}}$$

\bfhead{Data declarations.} A data declaration consists of the keyword
\kwd{DATA}, an optional identifier representing a label for the data,
an expression or a string constant, and a terminating semicolon.  A
backslash may optionally follow the string constant, indicating that
the string is unterminated (see
Section~\ref{sec:code-gen:declarations}).
%
$$\nonterm{const-decl} ::= \mbox{\kwd{DATA} \opt{\nonterm{identifier}}
  \group{\nonterm{expr} $|$ \group{\nonterm{string-const} \opt{\bs}}}
  \kwd{;}}$$

\bfhead{Variable declarations.} A variable declaration consists of the
keyword \kwd{VAR}, an identifier representing the variable name, a
signed or unsigned size, an optional initializer expression, and a
terminating semicolon:
%
$$\nonterm{var-decl} ::= \mbox{\kwd{VAR} \nonterm{identifier} \kwd{:}
  \nonterm{size} \opt{\kwd{S}} \opt{\kwd{=} \nonterm{expr}} \kwd{;}}$$

\bfhead{Function declarations.} A function declaration consists of the
keyword \kwd{FN}, an optional signed or unsigned size, an identifier
representing the function name, the function parameters enclosed in
parentheses, and the function body:
%
$$\nonterm{fn-decl} ::= \mbox{\kwd{FN} \opt{\kwd{:} \nonterm{size}
    \opt{\kwd{S}}} \nonterm{identifier} \kwd{(} \nonterm{fn-params}
  \kwd{)} \nonterm{fn-body}}$$
%
The function parameters are a comma-separated list of zero or more
parameters:
%
$$\nonterm{fn-params} ::= \mbox{\opt{\nonterm{fn-param} \group{\kwd{,}
    \nonterm{fn-param}}$^*$}}$$
%
A parameter consists of an identifier representing the parameter name
and a size:
%
$$\nonterm{fn-param} ::= \mbox{\nonterm{identifier} \kwd{:}
  \nonterm{size} \opt{\kwd{S}}}$$
%
A function body is either zero or more variable declarations and
statements enclosed in braces, or a semicolon indicating an externally
defined function:
%
$$\nonterm{fn-body} ::= \mbox{\kwd{\{} \nonterm{var-decl}$^*$
  \nonterm{stmt}$^*$ \kwd{\}} $|$ \kwd{;}}$$

\bfhead{Include declarations.} An include declaration consists of the
keyword \kwd{INCLUDE}, a string constant, and a terminating semicolon:
%
$$\nonterm{include-decl} ::= \mbox{\kwd{INCLUDE}
  \nonterm{string-const} \kwd{;}}$$
%

\subsection{Statements}
\label{sec:syntax:statements}

A statement is an if statement, a while statement, a return statement,
a block statement, or an expression statement:
%
$$\nonterm{stmt} ::= \mbox{\nonterm{if-stmt} $|$ \nonterm{while-stmt}
  $|$ \nonterm{return-stmt} $|$ \nonterm{block-stmt} $|$
  \nonterm{expr-stmt}}$$
%
\bfhead{If statements.} An if statement consists of the keyword
\kwd{IF}, a conditional expression enclosed in parentheses, a
statement to execute if the condition is true, and optionally the
keyword \kwd{ELSE} followed by a statement to execute if the condition
is false:
%
$$\nonterm{if-stmt} ::= \mbox{\kwd{IF} \kwd{(} \nonterm{expr} \kwd{)}
  \nonterm{stmt} \opt{\kwd{ELSE} \nonterm{stmt}}}$$
%

\bfhead{While statements.} A while statement consists of the keyword
\kwd{WHILE}, a test expression enclosed in parentheses, and a
statement to execute as long as the condition is true:
%
$$\nonterm{while-stmt} ::= \mbox{\kwd{WHILE} \kwd{(} \nonterm{expr}
  \kwd{)} \nonterm{stmt}}$$
%

\bfhead{Return statements.} A return statement consists of the keyword
\kwd{RETURN}, an optional expression, and a terminating semicolon:
%
$$\nonterm{return-stmt} ::= \mbox{\kwd{RETURN} \opt{\nonterm{expr}}
    \kwd{;}}$$
%

\bfhead{Block statements.} A block statement consists of zero or more
statements enclosed in braces:
%
$$\nonterm{block-stmt} ::= \mbox{\kwd{\{} \nonterm{stmt}$^*$
  \kwd{\}}}$$
%
\bfhead{Expresson statements.} An expression statement consists of an
expression followed by a terminating semicolon:
%
$$\nonterm{expr-stmt} ::= \mbox{\nonterm{expr} \kwd{;}}$$
%

\subsection{Expressions}
\label{sec:syntax:expressions}

An expression is an lvalue expression, a call expression, a set
expression, a binary operation expression, a unary operation
expression, a numeric constant, or a parentheses expression:
%
$$\nonterm{expr} ::= \mbox{\nonterm{lvalue-expr} $|$
  \nonterm{call-expr} $|$ \nonterm{set-expr} $|$ \nonterm{binop-expr}
  $|$ \nonterm{unop-expr} $|$ \nonterm{numeric-const} $|$
  \nonterm{parens-expr}}$$
%
An lvalue expression is an expression that may appear on the
right-hand side of a set expression.  It is an identifier, an indexed
expression, or a register expression:
%
$$\nonterm{lvalue-expr} ::= \mbox{\nonterm{identifier} $|$
  \nonterm{indexed-expr} $|$ \nonterm{register-expr}}$$
%
A numeric constant is an integer or character constant:
%
$$\nonterm{numeric-const} ::= \mbox{\nonterm{integer-const} $|$
  \nonterm{char-const}}$$
%

\bfhead{Indexed expressions.} An indexed expression consists of a
base expression, an offset expression, and a size:
%
$$\nonterm{indexed-expr} ::= \mbox{\nonterm{expr} \kwd{[}
    \nonterm{expr} \kwd{,} \nonterm{size} \kwd{]}}$$
%

\bfhead{Register expressions.} A register expression consists of a
caret character followed by a 6502 register name:
%
$$\nonterm{register-expr} ::= \mbox{\kwd{\^} \group{\kwd{A} $|$
    \kwd{X} $|$ \kwd{Y} $|$ \kwd{P} $|$ \kwd{S}}}$$
%

\bfhead{Call expressions.} A call expression consists of an expression
followed by an argument list enclosed in parentheses:
%
$$\nonterm{call-expr} ::= \mbox{\nonterm{expr} \kwd{(}
  \opt{\nonterm{expr} \group{\kwd{,} \nonterm{expr}}$^*$} \kwd{)}}$$
%


\bfhead{Set expressions.} A set expression consists of the keyword
\kwd{SET}, and lvalue expression, an equals sign, and a
right-hand-side expression:
%
$$\nonterm{set-expr} ::= \mbox{\kwd{SET} \nonterm{lvalue-expr} \kwd{=}
  \nonterm{expr}}$$
%

\bfhead{Binary operation expressions.} A binary operation expression
consists of a left-hand-side expression, a binary operator, and a
right-hand-side expression:
%
$$\nonterm{binop-expr} ::= \mbox{\nonterm{expr} \nonterm{binop} \nonterm{expr}}$$
%
$$\nonterm{binop} ::= \mbox{\kwd{>} $|$ \kwd{<} $|$ \kwd{<=} $|$
  \kwd{>=} $|$ \kwd{AND} $|$ \kwd{OR} $|$ \kwd{XOR} $|$ \kwd{+} $|$
  \kwd{-} $|$ \kwd{*} $|$ \kwd{/} $|$ \kwd{<<} $|$ \kwd{>>} $|$
  \kwd{=}}$$
%
\bfhead{Unary operation expressions.} A unary operation expression
consists of a unary operator followed by an expression:
%
$$\nonterm{unop-expr} ::= \mbox{\nonterm{unop} \nonterm{expr}}$$
%
$$\nonterm{unop} ::= \mbox{\kwd{@} $|$ \kwd{NOT} $|$ \kwd{-} $|$
  \kwd{INCR} $|$ \kwd{DECR}}$$
%
\bfhead{Parentheses expressions.} A parentheses expression is an
expression surrounded by parentheses:
%
$$\nonterm{parens-expr} ::= \mbox{\kwd{(} \nonterm{expr} \kwd{)}}$$
%

\section{Semantic Checking}
\label{sec:semantics}

\subsection{Attribution}

TODO

\subsection{Expression Sizes and Signedness}

TODO

\subsection{Function Arguments}

TODO

\subsection{LValues}

TODO

\subsection{Expression Statements}

TODO

\section{Code Generation}
\label{sec:code-gen}

\subsection{Source Files}
\label{sec:code-gen:source-files}

The AppleCore language is designed to support separate compilation.
To do that, the compiler translates source files to assembly files in
one of two modes: \emph{top-level mode} and \emph{include mode}.  The
mode must be specified at the time the source file is translated to
assembly, usually as a compiler option.

\bfhead{Top-Level Mode.}  In top-level mode, the compiler translates
the source file as follows:
%
\begin{enumerate}
%
\item Issue an assembler directive to include some preamble code that
  sets up the program stack.
%
\item Issue a \kwd{JMP} instruction to the first function appearing in
  the file.  There must be at least one such function, and it is a
  compile-time error if not.
%
\item Translate all declarations in the source file as described in
  Section~\ref{sec:code-gen:declarations}, in the order in which they
  appear in the source file.  Include declarations may appear anywhere
  in the file, and they are translated to directives to include the
  corresponding assembly files.
%
\item Issue assembler directives to include the AppleCore support code
  (for example, the code needed to do arithmetic operations).
%
\end{enumerate}

\bfhead{Include Mode.} In include mode, the compiler translates just
translates the declarations in the source file as described in
Section~\ref{sec:code-gen:declarations}.  No include directive or
\kwd{JMP} instruction to the first function is emitted.  In include
mode, the source program may not contain any include directives, and
it is a compile-time error for one to appear.

\bfhead{Assembling and Symbol Resolution.} A user program consists of
exactly one file translated in top-level mode and zero or more files
translated in include mode.  The final step in compilation is to ask
the assembler to assemble the file translated in top-level mode, which
includes all the other files for assembly.  This assembly also causes
name resolution for functions and constants defined in one file and
used in another.  It is the user's responsibility to ensure that
externally-defined names are both available and uniquely defined; the
compiler cannot check this.  If a symbol used in one of the assembled
files is not defined in any of the files (or if any symbol is multiply
defined), then an assembler error will result.

\subsection{Declarations}
\label{sec:code-gen:declarations}

TODO

\subsection{Statements}
\label{sec:code-gen:statements}

TODO

\subsection{Expressions}
\label{sec:code-gen:expressions}

TODO


\begin{comment}
If no backslash character appears after the second double-quote, then
the string is null-terminated:  in addition to storing the characters
appearing in the double-quotes, it stores a terminating NUL character
(value \$00).  If a backslash character appears after the second
double-quote, then the string is unterminated:  only the characters
appearing between the double-quotes are stored.
\end{comment}

\end{document}
