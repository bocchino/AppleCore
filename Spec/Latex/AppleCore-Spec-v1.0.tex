\documentclass[10pt]{article}

\input{defs}

\begin{document}

\title{\bfseries{The AppleCore Language Specification, v1.0}}
%
\author{Robert L. Bocchino Jr.\\
Pittsburgh, PA}
%
\date{Revised December 6, 2011}

\maketitle

\section{Introduction and Rationale}

AppleCore is a C-like programming language for the Apple II series of
computers.  A cross-compiler from Java (e.g., running on a Mac or PC)
to the Apple II is under development; eventually I would like to write
an AppleCore compiler in AppleCore, thereby providing a compiler that
works on the Apple II.

The idea of AppleCore is to provide a ``core language for programming
the Apple II.''  The motivation is as follows:
%
\begin{enumerate}
%
\item Programming the Apple II is both nostalgic and just plain fun.
%
\item The Apple II is a small machine.  Therefore it needs a
  lightweight programming model (i.e., without complicated runtime
  overhead in space or time).  The programming model must also provide
  (1) tight control over the layout of generated code and (2) easy
  integration with assembly-language support routines such as those
  provided by the System Monitor or Applesoft.
%
\item The native programming models on the Apple II are inadequate.
  Assembly language is powerful but painfully low-level.  Applesoft,
  on the other hand, is a disaster.  It lacks even the most basic
  abstraction required of a sane programming environment, including
  scoped loops, scoped functions with local variables, and variable
  names longer than \emph{two letters}!  Applesoft does have nice
  support for numeric and string input and output, so if you just want
  to write short programs that read and write things, it's handy. But
  for any but the tiniest programs, Applesoft code becomes an
  unreadable mess.  In terms of control abstraction Applesoft is
  actually worse than assembly language, because it forces you to
  branch to numbered lines, whereas in assembly language you can
  \kwd{JMP} and \kwd{JSR} to symbolic labels with meaningful names.
%
\end{enumerate}

The goal of AppleCore is to rectify this situation by providing a
low-level language with some minimal programming abstractions that's
both useful and fun to program with.  First, it's a compiled language,
so it should run faster than Applesoft.  Second, it's modular and
supports separate compilation. The entire core language needs only a
few kilobytes of support routines; additional routines can be linked
in as needed.  Third, AppleCore strikes a balance between power and
efficiency.  Notably, it supports integer arithmetic on fixed-size
variables of up to 255 bytes, so it essentially gives
arbitrary-precision arithmetic.  This power does come at a cost in
terms of speed for single-byte arithmetic that could be done in
registers; however, if that speed is needed, one can easily call into
assembly language arithmetic routines.  Fourth, it provides easy
integration with assembly language routines; in particular, you can
say things like ``load `A' into the accumulator and call \$FDED'' that
are impossible to say in Applesoft or other high-level languages
without assembly-language wrapper code.

The main things that AppleCore lacks, and that Applesoft provides, are
automatic memory management and floating-point computation.  I've left
out memory management to keep things very simple.  Basically, as a
programmer I can't live happily without control abstractions (loops
and functions); but once I have them I'm perfectly content to
synthesize data abstractions on my own.  If this becomes too much of a
pain, a library for memory management can be added without difficulty,
after the fashion of C.  (Applesoft actually provides garbage
collection, but it works very poorly, causing the machine to seize up
when the memory limit is reached.)  I've left out floating-point
computation mainly because I'm most interested in text processing and
integer computations; but again, FP computations can be added without
too much difficulty.  In the mean time, one can fake FP computations
by encoding FP literals as string data and calling into the Applesoft
FP routines to convert from strings to FP numbers and back, and to
compute using the FP numbers.  Applesoft is actually quite good at
this.

\section{Lexical Structure}

Before parsing a source file, the source text is separated into
\emph{tokens}.  There are four classes of tokens: identifiers,
keywords, constants, and symbols.

\subsection{White Space}
\label{sec:lexical:white-space}

White space consists of any sequence of the following characters:
space (ASCII SP, value \$20), newline (ASCII NL, value \$0A), carriage
return (ASCII CR, value \$0D), and horizontal tab (ASCII HT, value
\$09).  Whitespace is syntactically relevant only in the following
ways:
%
\begin{enumerate}
%
\item \ithead{Separation of tokens.} When a whitespace character or end of
file appears immediately after a non-whitespace character, that
signifies the end of a token.
%
\item \ithead{End of line.} An end-of-line sequence (\kwd{EOL}) is a
  comment terminator (see Section~\ref{sec:lexical:comments}).  As
  usual, the definition of \kwd{EOL} is platform-dependent: on the
  Apple II it is CR, on UNIX it is NL, and on Windows it is CR
  followed by NL.
%
\end{enumerate}
%
The lexer may also count source lines (using \kwd{EOL}) to provide
line numbers for error messages.

\subsection{Identifiers}\label{Identifiers}

An identifier is a sequence of letters (including the underscore
character) and digits that is not a keyword.  The first character must
be a letter.  Upper- and lowercase letters are distinct.

\subsection{Keywords}

The following sequences of characters are reserved for use as keywords
and may not be used as identifiers:
\begin{ttfamily}
\begin{center}
\begin{tabular}{l l l l}
AND & CONST & DATA & DECR \\
%
ELSE & FN & IF & INCLUDE \\
%
INCR & NOT & OR & RETURN \\
%
SET & VAR & XOR & WHILE \\
\end{tabular}
\end{center}
\end{ttfamily}

Following Apple II tradition (mostly because the original Apple II had
no support for lower-case letters), AppleCore keywords are uppercase.
That means that the same words in lowercase (or a combination of
upper- and lowercase) are not recognized as keywords, so those
sequences of characters are availble for use as identifiers.

\subsection{Constants}
\label{sec:lexical:constants}

There are three types of constants: integer constants, string
constants, and character constants.  

\bfhead{Integer constants.}  Integer constants may be written in
decimal or hexadecimal form.  A decimal integer constant consists of
one or more decimal digits \kwd{0} through \kwd{9}.  For example,
\kwd{1} and \kwd{123} are valid integer constants in decimal form.  A
hexadecimal integer constant consists of a dollar sign \kwd{\$}
followed by by one or more hexadecimal digits \kwd{0} through \kwd{9}
or \kwd{A} through \kwd{F}.  For example, \kwd{\$1}, \kwd{\$A}, and
\kwd{\$00FF} are valid integer constants in hexadecimal form.

Integer constants represent values with up to 255 bytes of precision
(i.e., in the range $0$ through $2^{255 \cdot 8}-1$, inclusive).  It
is a compile-time error to write an integer constant with a value
larger than that.

\bfhead{String constants.} A string constant is a sequence of
characters enclosed in double quotes (\kwd{"..."}).  A string constant
represents a sequence of ASCII characters, one for each character
appearing in the double-quotes, except that the character sequence
\kwd{\bs\$} has the special meaning described below.

Since not all ASCII characters have printable representations, an
\emph{escape sequence} may be used to represent an arbitrary ASCII
value (printable or non-printable).  An escape sequence consists of a
backslash \kwd{\bs} followed by a dollar sign \kwd{\$} and two
hexadecimal digits.  The whole sequence represents the single
character with the ASCII value given by the digits.  For example, the
string constant
%
$$\kwd{"Hello, world!\bs\$0D"}$$
%
represents a string consisting of the characters \kwd{Hello, world!}
followed by a CR character.  Similarly, the quote character \kwd{"}
can be embedded in a string constant with the sequence \kwd{\bs\$22}.

\bfhead{Character constants.} A character constant consists of a
single-quote character \kwd{'}, followed by a printable ASCII
character, followed by another single-quote character.  It represents
the ASCII value associated with the character.  For example, the
constant \kwd{'A'} represents the value $\$41$.

\subsection{Symbols}

AppleCore uses the symbols shown in Figure~\ref{fig:symbols}, each of
which is a separate token.

\begin{figure}[th]
\begin{center}
\begin{tabular}{c l}
\textbf{Symbol} & \textbf{Meaning} \\
%
\kwd{@} & Denotes the address of a variable \\
%
\kwd{\^} & Denotes a 6502 register expression \\
\kwd{*}  & Multiplication \\
\kwd{/}  & Division \\
\kwd{+}  & Addition \\
\kwd{-}  & Negation (as unary operator); subtraction (as binary
operator) \\
\kwd{<<} & Left shift \\
\kwd{>>} & Right shift \\
\kwd{>=} & Greater than or equal to \\
\kwd{<=} & Less than or equal to \\
\kwd{>}  & Greater than \\
\kwd{<}  & Less than \\
\kwd{=}  & Equal to; assignment \\
\kwd{(} and \kwd{)} & Encloses function parameters and arguments, parenthesized expressions
\\
\kwd{\{} and \kwd{\}} & Encloses statement blocks \\
\kwd{[} and \kwd{]} & Pointer dereference \\
\kwd{;} & Terminates declarations and statements \\
\kwd{:} & Separates variable declaration from size \\
\kwd{,} & Separates function parameters and arguments; separates index from size in dereference \\
\end{tabular}
\end{center}
\caption{Symbols used in AppleCore syntax.}
\label{fig:symbols}
\end{figure}

\subsection{Comments}
\label{sec:lexical:comments}

The character \kwd{\#} indicates a comment; all text to the next end
of line (or end of file, if there is no end of line) are ignored by
the lexer.  Multiline comments are indicated by preceding each line
with \kwd{\#}.

\section{Syntax}
\label{sec:syntax}

The syntax description below uses the following conventions:
%
\begin{itemize}
%
\item The symbol $^*$ denotes zero or more instances of the entity
  preceding it.
%
\item Italicized parentheses \group{} group the enclosed symbols and
  do not denote program text.
%
\item Italicized brackets \opt{} signify that the enclosed symbols are
  optional (i.e., they may occur zero or one time).  They do not
  denote program text.
%
\item The nonterminal \nonterm{identifier} stands for any identifier
  as defined in Section \ref{Identifiers}.
%
\item The nonterminals \nonterm{integer-const},
  \nonterm{string-const}, and \nonterm{char-const} stand for integer,
  string, and character constants as defined in
  Section~\ref{sec:lexical:constants}.
%
\item The nonterminal \nonterm{size} refers to an integer constant
  whose value is between 1 and 255 (inclusive).
%
\item Text and symbols in \kwd{typewriter} font (including
  non-italicized parentheses and brackets) denote literal program
  text.
%
\end{itemize}

\subsection{Source Files}
\label{sec:syntax:source-files}

The basic syntactic unit of an AppleCore program is a \emph{source
  file}, i.e., an input file presented to the AppleCore compiler for
compilation.  The compiler translates the source file into an assembly
file which is then linked with other assembly files as discussed in
Section~\ref{sec:code-gen:source-files} to form a complete executable
program.

An AppleCore source file is given by zero or more
declarations (Section~\ref{sec:syntax:decls}):
%
$$\nonterm{source-file} ::= \nonterm{decl}^*$$
%

\subsection{Declarations}
\label{sec:syntax:decls}

A declaration is a constant declaration, a data declaration, a
variable declaration, a function declaration, or an include
declaration:
%
$$\nonterm{decl} ::= \mbox{\nonterm{const-decl} $|$
  \nonterm{data-decl} $|$ \nonterm{var-decl} $|$ \nonterm{fn-decl}
    $|$ \nonterm{include-decl}}$$

\bfhead{Constant declarations.} A constant declaration consists of the
keyword \kwd{CONST}, an identifier, an expression, and a terminating
semicolon:
%
$$\nonterm{const-decl} ::= \mbox{\kwd{CONST} \nonterm{identifier}
  \nonterm{expr} \kwd{;}}$$

\bfhead{Data declarations.} A data declaration consists of the keyword
\kwd{DATA}, an optional identifier representing a label for the data,
an expression or a string constant, and a terminating semicolon.  A
backslash may optionally follow the string constant, indicating that
the string is unterminated (see
Section~\ref{sec:code-gen:global-decls}).
%
$$\nonterm{const-decl} ::= \mbox{\kwd{DATA} \opt{\nonterm{identifier}}
  \group{\nonterm{expr} $|$ \group{\nonterm{string-const} \opt{\bs}}}
  \kwd{;}}$$

\bfhead{Variable declarations.} A variable declaration consists of the
keyword \kwd{VAR}, an identifier representing the variable name, a
signed or unsigned size, an optional initializer expression, and a
terminating semicolon:
%
$$\nonterm{var-decl} ::= \mbox{\kwd{VAR} \nonterm{identifier} \kwd{:}
  \nonterm{size} \opt{\kwd{S}} \opt{\kwd{=} \nonterm{expr}} \kwd{;}}$$

\bfhead{Function declarations.} A function declaration consists of the
keyword \kwd{FN}, an optional signed or unsigned size, an identifier
representing the function name, the function parameters enclosed in
parentheses, and the function body:
%
$$\nonterm{fn-decl} ::= \mbox{\kwd{FN} \opt{\kwd{:} \nonterm{size}
    \opt{\kwd{S}}} \nonterm{identifier} \kwd{(} \nonterm{fn-params}
  \kwd{)} \nonterm{fn-body}}$$
%
The function parameters are a comma-separated list of zero or more
parameters:
%
$$\nonterm{fn-params} ::= \mbox{\opt{\nonterm{fn-param} \group{\kwd{,}
    \nonterm{fn-param}}$^*$}}$$
%
A parameter consists of an identifier representing the parameter name
and a size:
%
$$\nonterm{fn-param} ::= \mbox{\nonterm{identifier} \kwd{:}
  \nonterm{size} \opt{\kwd{S}}}$$
%
A function body is either zero or more variable declarations and
statements enclosed in braces, or a semicolon indicating an externally
defined function:
%
$$\nonterm{fn-body} ::= \mbox{\kwd{\{} \nonterm{var-decl}$^*$
  \nonterm{stmt}$^*$ \kwd{\}} $|$ \kwd{;}}$$

\bfhead{Include declarations.} An include declaration consists of the
keyword \kwd{INCLUDE}, a string constant, and a terminating semicolon:
%
$$\nonterm{include-decl} ::= \mbox{\kwd{INCLUDE}
  \nonterm{string-const} \kwd{;}}$$
%

\subsection{Statements}
\label{sec:syntax:statements}

A statement is an if statement, a while statement, a return statement,
a block statement, or an expression statement:
%
$$\nonterm{stmt} ::= \mbox{\nonterm{if-stmt} $|$ \nonterm{while-stmt}
  $|$ \nonterm{return-stmt} $|$ \nonterm{block-stmt} $|$
  \nonterm{expr-stmt}}$$
%
\bfhead{If statements.} An if statement consists of the keyword
\kwd{IF}, a conditional expression enclosed in parentheses, a
statement to execute if the condition is true, and optionally the
keyword \kwd{ELSE} followed by a statement to execute if the condition
is false:
%
$$\nonterm{if-stmt} ::= \mbox{\kwd{IF} \kwd{(} \nonterm{expr} \kwd{)}
  \nonterm{stmt} \opt{\kwd{ELSE} \nonterm{stmt}}}$$
%

\bfhead{While statements.} A while statement consists of the keyword
\kwd{WHILE}, a test expression enclosed in parentheses, and a
statement to execute as long as the condition is true:
%
$$\nonterm{while-stmt} ::= \mbox{\kwd{WHILE} \kwd{(} \nonterm{expr}
  \kwd{)} \nonterm{stmt}}$$
%

\bfhead{Return statements.} A return statement consists of the keyword
\kwd{RETURN}, an optional expression, and a terminating semicolon:
%
$$\nonterm{return-stmt} ::= \mbox{\kwd{RETURN} \opt{\nonterm{expr}}
    \kwd{;}}$$
%

\bfhead{Block statements.} A block statement consists of zero or more
statements enclosed in braces:
%
$$\nonterm{block-stmt} ::= \mbox{\kwd{\{} \nonterm{stmt}$^*$
  \kwd{\}}}$$
%
\bfhead{Expresson statements.} An expression statement consists of an
expression followed by a terminating semicolon:
%
$$\nonterm{expr-stmt} ::= \mbox{\nonterm{expr} \kwd{;}}$$
%

\subsection{Expressions}
\label{sec:syntax:expressions}

An expression is an lvalue expression, a call expression, a set
expression, a binary operation expression, a unary operation
expression, a numeric constant, or a parentheses expression:
%
$$\nonterm{expr} ::= \mbox{\nonterm{lvalue-expr} $|$
  \nonterm{call-expr} $|$ \nonterm{set-expr} $|$ \nonterm{binop-expr}
  $|$ \nonterm{unop-expr} $|$ \nonterm{numeric-const} $|$
  \nonterm{parens-expr}}$$

\bfhead{Lvalue expressions.}  An lvalue expression is an expression
that may appear on the left-hand side of a set expression.  It is an
identifier, an indexed expression, or a register expression:
%
$$\nonterm{lvalue-expr} ::= \mbox{\nonterm{identifier} $|$
  \nonterm{indexed-expr} $|$ \nonterm{register-expr}}$$

\bfhead{Numeric constants.}  A numeric constant is an integer or
character constant:
%
$$\nonterm{numeric-const} ::= \mbox{\nonterm{integer-const} $|$
  \nonterm{char-const}}$$
%

\bfhead{Indexed expressions.} An indexed expression consists of a
base expression, an offset expression, and a size:
%
$$\nonterm{indexed-expr} ::= \mbox{\nonterm{expr} \kwd{[}
    \nonterm{expr} \kwd{,} \nonterm{size} \kwd{]}}$$
%

\bfhead{Register expressions.} A register expression consists of a
caret character followed by a 6502 register name:
%
$$\nonterm{register-expr} ::= \mbox{\kwd{\^} \group{\kwd{A} $|$
    \kwd{X} $|$ \kwd{Y} $|$ \kwd{P} $|$ \kwd{S}}}$$
%

\bfhead{Call expressions.} A call expression consists of an expression
followed by an argument list enclosed in parentheses:
%
$$\nonterm{call-expr} ::= \mbox{\nonterm{expr} \kwd{(}
  \opt{\nonterm{expr} \group{\kwd{,} \nonterm{expr}}$^*$} \kwd{)}}$$
%


\bfhead{Set expressions.} A set expression consists of the keyword
\kwd{SET}, and lvalue expression, an equals sign, and a
right-hand-side expression:
%
$$\nonterm{set-expr} ::= \mbox{\kwd{SET} \nonterm{lvalue-expr} \kwd{=}
  \nonterm{expr}}$$
%

\bfhead{Binary operation expressions.} A binary operation expression
consists of a left-hand-side expression, a binary operator, and a
right-hand-side expression:
%
$$\nonterm{binop-expr} ::= \mbox{\nonterm{expr} \nonterm{binop} \nonterm{expr}}$$
%
$$\nonterm{binop} ::= \mbox{\kwd{>} $|$ \kwd{<} $|$ \kwd{<=} $|$
  \kwd{>=} $|$ \kwd{AND} $|$ \kwd{OR} $|$ \kwd{XOR} $|$ \kwd{+} $|$
  \kwd{-} $|$ \kwd{*} $|$ \kwd{/} $|$ \kwd{<<} $|$ \kwd{>>} $|$
  \kwd{=}}$$
%
\bfhead{Unary operation expressions.} A unary operation expression
consists of a unary operator followed by an expression:
%
$$\nonterm{unop-expr} ::= \mbox{\nonterm{unop} \nonterm{expr}}$$
%
$$\nonterm{unop} ::= \mbox{\kwd{@} $|$ \kwd{NOT} $|$ \kwd{-} $|$
  \kwd{INCR} $|$ \kwd{DECR}}$$
%
\bfhead{Parentheses expressions.} A parentheses expression is an
expression surrounded by parentheses:
%
$$\nonterm{parens-expr} ::= \mbox{\kwd{(} \nonterm{expr} \kwd{)}}$$
%

\section{Semantic Checking}
\label{sec:semantics}

The compiler checks every source file for conformance to the semantic
rules stated below.  A semantically invalid program (i.e., one that
violates one of these rules) generates a compile-time error and causes
compilation to halt.  Only semantically valid files go on to code
generation as described in Section~\ref{sec:code-gen}.

\subsection{Attribution}
\label{sec:semantics:attr}

During attribution, the compiler associates each identifier appearing
in the source file with its corresponding definition.  For purposes of
these rules, a \emph{definition} is a constant declaration, data
declaration, variable declaration, function parameter declaration, or
function declaration.  A \emph{use} is any identifier appearing in the
source file not as the identifier of a definition.

The compiler matches definitions with uses in the following way:
%
\begin{enumerate}
%
\item At global scope (i.e., outside of any function body), for each
  use find the corresponding definition with the same identifier at
  global scope.  If there is no corresponding definition, or if any
  two definitions use the same identifier, then  report an error.
%
\item At function scope (i.e., inside a function body), for each use
  find the corresponding definition with the same identifier either in
  the function scope.  The function scope consists of the global scope
  together with all function parameters and local variables declared
  in the function.  If there is no corresponding definition, or if any
  two definitions in the scope consisting of the function scope use
  the same identifier, then report an error.
%
\end{enumerate}
%
Definitions need not precede their uses in the source file.

\subsection{Sizes and Signedness}

\bfhead{Expressions.} Every expression is given a \emph{size} and a
\emph{signedness}, computed as follows:
%
\begin{itemize}
%
\item \ithead{Identifiers.} The size and signedness of an identifier
  expression come from its definition
  (Section~\ref{sec:semantics:attr}).  (1) If the definition is a
  constant declaration, then the size and signedness are identical to
  the size and signedness of the expression appearing in the
  declaration.  (2) If the definition is a variable declaration or
  function parameter declaration, then (a) the size is as given in the
  declaration, and (b) the signedness is signed if \kwd{S} appears
  after the size, otherwise unsigned.  (3) If the definition is a data
  declaration or function declaration, then the size is 2 and the
  signedness is unsigned.
%
\item \ithead{Indexed expressions.} The size of an indexed expression
  is given by the \nonterm{size} component of the expression.  It is
  always unsigned.  Both the expression being indexed (before the
  first bracket) and the index expression (immediately after the first
  bracket) must have size 1 or 2.
%
\item \ithead{Register expressions.} The size of a register expression
  is 1.  It is unsigned.
%
\item \ithead{Call expressions.} (1) The called expression (i.e., the
  expression before the first parenthesis) must be an expression of
  size 1 or 2.  (2) If the called expression is an identifier
  corresponding to a function declaration, then the size and
  signedness are the return size and signedness of the function
  definition (see below); otherwise the size is 0 and the signedness
  is unsigned.  (3) Each argument expression must have nonzero size.
%
\item \ithead{Set expressions.} The size and signedness of a set
  expression come from the left-hand-side expression.  The right-hand
  expression must have nonzero size.
%
\item \ithead{Binary operation expressions.}  For comparison
  operations, the size is 1 byte unsigned.  For shift operations, the
  size and signedness come from the left operand, and the right
  operand must be 1 byte unsigned.  For all other operations, the size
  is the maximum of the sizes of its operands.  If either of the
  operands is signed, then the result is signed.  Otherwise, the
  result is unsigned.
%
\item \ithead{Unary operation expressions.} The size and signedness of
  a unop expression come from the operand, except that (1) an address
  operation \kwd{@} is two bytes unsigned, and (2) a negation
  operation is signed.
%
\item \ithead{Numeric constants.} The size of a constant expression is
  the size of the constant it represents.  A character constant has
  size 1, and an integer constant has size equal to the smallest
  number of bytes required to represent the value.  Numeric constant
  expressions are unsigned.
%
\item \ithead{Parentheses expressions.} The size and signedness of a
  parentheses expression come from the enclosed expression.
%
\end{itemize}

\bfhead{Function declarations.} (1) The \emph{return size and
  signedness} of a function declaration are defined as follows.  If a
\nonterm{size} appears after the keyword \kwd{FN} in the definition,
then that is the return size; otherwise the return size is 0.  If
\kwd{S} appears after \nonterm{size} then the return signedness is
signed, otherwise unsigned. (2) The \emph{frame size} of a function
declaration that contains a body equals 2 (for the frame pointer) plus
the sizes of all the function parameters and local variables.  No
function may have a frame size of greater than 255 bytes.

\bfhead{Return statements.} (1) No return statement may contain an
expression of zero size.  (2) If a function has nonzero return size,
and the function has a body, then (a) the body must end with a return
statement containing an expression, and (b) every return statement
appearing in the body must contain an expression.  (3) If a function
has return size 0, then no return statement in the function body may
contain an expression.


\subsection{Number of Function Arguments}
\label{sec:semantics:fn-args}

At every call expression where the called expression is an identifier
corresponding to a function declaration, the number of arguments must
match the number of parameters given in the declaration.

\subsection{Semantic LValues}
\label{sec:semantics:lvalues}

\bfhead{Definition of semantic lvalue.}  A \emph{semantic lvalue} is
an expression that (1) is an lvalue expression
(Section~\ref{sec:syntax:expressions}) and (2) if it is an identifier,
then it corresponds to a variable or function parameter declaration.

\bfhead{Requirement of semantic lvalues.}  (1) A semantic lvalue is
required in the following places: (a) on the left-hand side of a set
expression; and (b) as the operand of an address (\kwd{@}), increment
(\kwd{INCR}), or decrement (\kwd{DECR}) operator.  If an expression
that is not a semantic lvalue appears in any of these places, then a
compile-time error results.  (2) A compile-time error results if a
register expression appears as the operand of an address (\kwd{@})
operator.


\subsection{Expression Statements}
\label{sec:semantics:expr-stmts}

The expression contained in an expression statement have an effect:
that is, it must be a set, call, \kwd{INCR}, or \kwd{DECR} expression.
This check traps the error of writing \kwd{X = 2;} (comparison)
instead of \kwd{SET X = 2;} (assignment).

\subsection{Expressions Appearing at Global Scope}

An expression appearing at global scope (i.e., in a constant or data
delcaration, or as the initializer of a global variable declaration)
must evaluate to a compile-time constant according to the rules for
expression evaluation stated in
Section~\ref{sec:code-gen:expressions}.

\section{Code Generation}
\label{sec:code-gen}

\subsection{Source Files}
\label{sec:code-gen:source-files}

The AppleCore language is designed to support separate compilation.
To do that, the compiler translates source files to assembly files in
one of two modes: \emph{top-level mode} and \emph{include mode}.  The
mode must be specified at the time the source file is translated to
assembly, usually as a compiler option.

\bfhead{Top-level mode.}  In top-level mode, the compiler translates
the source file as follows:
%
\begin{enumerate}
%
\item Issue some code (or an assembler directive to include the code)
  that sets up the program stack.
%
\item Issue a \kwd{JMP} instruction to (or fall in to) the first
  function with a body that appears in the file.  There must be at
  least one such function, and it is a compile-time error if not.
%
\item Translate all global declarations in the source file as
  described in Section~\ref{sec:code-gen:global-decls}, in the
  order in which they appear in the source file.  Include declarations
  may appear anywhere in the file, and they are translated to
  directives to include the corresponding assembly files.
%
\item Issue assembler directives to include the AppleCore support code
  (for example, the code needed to do arithmetic operations).
%
\end{enumerate}

\bfhead{Include mode.} In include mode, the compiler just translates
the declarations in the source file as described in
Section~\ref{sec:code-gen:global-decls}.  No include directive or
\kwd{JMP} instruction to the first function is emitted.  In include
mode, the source program may not contain any include directives, and
it is a compile-time error for one to appear.

\bfhead{Final assembly and symbol resolution.} A user program consists
of exactly one file translated in top-level mode and zero or more
files translated in include mode.  The final step in compilation is to
ask the assembler to assemble the file translated in top-level mode,
which includes all the other files for assembly.  This assembly also
causes name resolution for functions and constants defined in one file
and used in another.  It is the user's responsibility to ensure that
externally-defined names are both available and uniquely defined; the
compiler cannot check this.  If a symbol used in one of the assembled
files is not defined in any of the files (or if any symbol is multiply
defined), then an assembler error will result.

\subsection{Global Declarations}
\label{sec:code-gen:global-decls}

Global declarations are translated as stated below.  To the extent
that translation produces actual bytes of machine code, data, or
reserved storage, the bytes must be laid out in the order in which the
translated constructs are encountered in the source file.

\bfhead{Constant declarations.} The compiler (1) evaluates the
expression of the constant declaration to a numeric constant according
to the rules in Section~\ref{sec:code-gen:expressions} and (2)
associates this value with the name given in the constant declaration.
The compiler may, but need not, use assembler directives such as
\kwd{.EQ} to implement this association (generally such directives
work only for 1- or 2-byte values).  Alternatively, the compiler can
materialze the value (or the component bytes of the value) at every
use of the name.

\bfhead{Data declarations.} (1) If an expression appears before the
semicolon, then the compiler evaluates the expression to a numeric
constant according to the rules in
Section~\ref{sec:code-gen:expressions} and generates code to store the
bytes of the constant in little-endian order.  (2) If a string
constant appears before the semicolon, then the compiler generates
assembly code to store the bytes of the string constant in
left-to-right order.  (a) If no backslash \kwd{\bs} follows the string
constant, then the compiler adds a terminating NUL (\$00) character
after the last byte of string data. (b) If a backslash follows the
string constant, then no NUL character is added.  (3) In any case, if
an identifier appears after the keyword \kwd{DATA}, then the compiler
associates the name with the lowest address in which data is stored.

\bfhead{Global variable declarations.} The compiler sets aside a
number of bytes of storage equal to the declared size of the variable
and associates the identifier appearing after \kwd{VAR} with the
lowest address of this storage.  If an expression appears before the
semicolon, then the compiler evaluates the expression to a numeric
constant according to the rules stated in
Section~\ref{sec:code-gen:expressions} and issues assembly code to
fill in the storage set aside for the variable with the bytes of the
numeric constant, in little-endian order, using size adjustment (if
necessary) as stated in Secton~\ref{sec:code-gen:size-adjustment}.

\bfhead{Function declarations.} (1) A function declaration with no
body does not correspond to any generated code; its signature is used
only for checking call expressions that invoke the function.  (2) A
function declaration with a body causes code to be generated as stated
in Section~\ref{sec:code-gen:fn-bodies}.

\bfhead{Include declarations.}  In top-level mode (see
Section~\ref{sec:code-gen:source-files}), the compiler translates an
include declaration into an assembler directive to include the file
named in the string constant.  In include mode, the presence of an
include declaration in the source file causes an error.

\subsection{Function Bodies}
\label{sec:code-gen:fn-bodies}

The AppleCore language definition assumes a C-style function call
stack as specified in Section~\ref{sec:code-gen:program-stack}.  For
each function declaration that has a body, the compiler does the
following:
%
\begin{itemize}
%
\item Generate code to reserve slots on the call stack for the
  function parameters, local variables, and saved registers.  The
  saved registers are all the registers appearing in register
  expressions in the function body.
%
\item For each local variable declaration that includes an initializer
  expression, generate code to evaluate the expression according to
  the rules in Section~\ref{sec:code-gen:expressions} and assign the
  resulting value into the stack slot for the variable, using size
  adjustment (if necessary) as stated in
  Section~\ref{sec:code-gen:size-adjustment}.
%
\item For each statement of the function body, generate code as stated
  in Section~\ref{sec:code-gen:statements}.  The statements of a
  function body are executed in sequence, in the order in which they
  appear in the program text.
%
\item If the function body does not end in a return statement,
  generate code to pop the frame off the stack and restore the parent
  frame.
%
\end{itemize}


\subsection{Statements}
\label{sec:code-gen:statements}

The compiler generates code to do the following for each program
statement.

\bfhead{If statements.} Evaluate the conditional expression
(Section~\ref{sec:code-gen:expressions}), pop the result off the
expression stack, and mask off all but the lowest bit of the result to
get the corresponding Boolean value
(Section~\ref{sec:code-gen:boolean}).  If the Boolean value of the
result is 1 (true), then execute the true part.  If the Boolean value
of the result is 0 (false), either do nothing (if there is no optional
\kwd{ELSE} clause) or execute the statement in the \kwd{ELSE} clause
(if one is provided).

\bfhead{While statements.} Evaluate the conditional expression
(Section~\ref{sec:code-gen:expressions}), pop the result off the
expression stack, and mask off all but the lowest bit of the result to
get the corresponding Boolean value
(Section~\ref{sec:code-gen:boolean}).  If the Boolean value of the
result is 1 (true), then execute the body of the loop and repeat the
whole process.  If the Boolean value of the result is 0 (false), then
do nothing.

\bfhead{Return statements.} (1) If the statement contains an
expression, then evaluate the expression
(Section~\ref{sec:code-gen:expressions}).  (2) Pop the current frame
off the call stack and restore the parent frame.  (3) If the statement
contains an expression, then pop the result off the expression stack
and push it on the call stack so it can be accessed by the caller
expression on return.

\bfhead{Block statements.} Execute each statement of the block in the
order in which it appears in the program text.

\bfhead{Expression statements.} Evaluate the expression contained in
the statement (Section~\ref{sec:code-gen:expressions}) and pop the
result off the expression stack.

\subsection{Expressions}
\label{sec:code-gen:expressions}

We define the semantics of expressions using an expression stack, as
specified in Section~\ref{sec:code-gen:program-stack}.  The compiler
generates code to do the following for each program expression.

\bfhead{Identifiers.} TODO

\bfhead{Indexed expressions.} TODO

\bfhead{Register expressions.} Evaluation of a register expression
causes the current value stored in the function call stack slot for
that register (Section~\ref{sec:code-gen:fn-bodies}) to be pushed on
the expression stack.

\bfhead{Call expressions.} TODO

\bfhead{Set expressions.} TODO

\bfhead{Binary operation expressions.} TODO

\bfhead{Unary operation expressions.} TODO

\bfhead{Numeric constants.} TODO

\bfhead{Parentheses expressions.} Evaluation of a parentheses
expression is carried out by evaluating the expression inside the
paretheses.


\subsection{Boolean Values}
\label{sec:code-gen:boolean}

The AppleCore language has no special Boolean type; as in C, ordinary
integers serve as Boolean values.  However, AppleCore differs from C
in what values it treats as ``true'' and ``false.''  In AppleCore,
only the lowest-order bit is relevant in testing the Boolean value of
an integer: integers whose low bit is 1 (i.e., odd integers) all count
as ``true,'' while integers whose low bit is 0 (i.e., even integers)
all count as ``false.''  This mechanism allows bitwise \kwd{NOT} to
function as logical \kwd{NOT}, without any need for a separate logical
negation operator, and that keeps the language simple.  Also, the
constants 1 and 0 can function as ``true'' and ``false.''  These names
and values are not built into the language, but one can easily declare
constants \kwd{TRUE} and \kwd{FALSE} with the values 1 and 0.

\subsection{Size Adjustment}
\label{sec:code-gen:size-adjustment}

\emph{Size adjustment} applies whenever the result of evaluating an
expression (the source value) is assigned into a semantic lvalue (the
target value) and the sizes of the source and target values do not
match.  The following rules apply to size adjustment:
%
\begin{enumerate}
%
\item If the source value size is greater than the target value size,
  then high-order bytes of the source value are \emph{truncated}: only
  the low-order bytes of the source value are stored, up to the number
  of bytes required by the target value.
%
\item If the source value size is smaller than the target value size,
  and the source value is unsigned, then the source value is
  \emph{zero extended}:  the bytes of the source value form the
  low-order bytes of the target value, and zeros are used to fill the
  rest of the bytes of the target value.
%
\item If the source value size is smaller than the target value size,
  and the source value is signed, then the source value is \emph{sign
    extended}: the bytes of the source value form the low-order bytes
  of the target value, and the rest of the bytes of the target value
  are filed with either all 0 bits (if the high-order bit of the
  source value is 0) or all 1 bits (if the high-order bit of the
  source value is 1).
%
\end{enumerate}

\subsection{Program Stack}
\label{sec:code-gen:program-stack}

This specification requires that the implementation provide three
stacks for use at runtime, collectively referred to as the
\emph{program stack}:
%
\begin{enumerate}
%
\item A C-style \emph{call stack}, such that a new frame appears at
  the top of the stack for each function call, and the frame is popped
  at the end of the call.  This stack is used in generating function
  call code, as specified in Section~\ref{sec:code-gen:fn-bodies}.
%
\item An \emph{expression stack} for use during expression evaluation
  as specified in Section~\ref{sec:code-gen:expressions}.
%
\item An \emph{allocation stack} that supports an \kwd{ALLOCATE}
  library function that works as follows.  (1) \kwd{ALLOCATE} is only
  ever called in a function scope, when no temporary expression result
  is on the expression stack; otherwise the results are undefined.
  (2) When \kwd{ALLOCATE} is called, it is passed a two-byte size
  value $s$.  (3) (a) If there is enough space on the stack, then
  \kwd{ALLOCATE} returns a pointer to $s$ bytes on the stack. (b) If
  there are not $s$ bytes remaining on the stack, then the results are
  undefined. (4) The $s$ bytes pointed to by the result of the
  \kwd{ALLOCATE} call remain valid (i.e., are not modified except by
  user-written code) during the lifetime of the call stack frame for
  the function in which the \kwd{ALLOCATE} call occured.  (5) At the
  end of the function in which the \kwd{ALLOCATE} call occurred, the
  memory is deallocated and may be reused as program stack storage.
%
\end{enumerate}

The compiler may provide this stack functionality in any way that is
feasible.  Typically, the generated code would maintain its own
two-byte stack pointer, because the native Apple II stack located at
addresses \$200 through \$2FF is too small to serve as the program
stack for this language.  However, this specification does not mandate
any particular stack size; the actual available stack size depends on
both the compiler implementation and the program memory requirements
(for example, whether the graphics and/or language card areas are
available for program heap and stack data).  Also, typically the same
physical stack would be used for all three logical stacks (and the
logical stacks have been specified so that this is possible), but this
is not a requirement.


\end{document}
